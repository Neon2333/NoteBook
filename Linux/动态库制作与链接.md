# 制作动态库

当静态库改变时，需要将生成的新的静态库和目标程序.out文件重新链接，比较繁琐。但使用静态库的目标程序中已有所有需要的函数，所以可移植性较高。

使用动态库时，当动态库中发生了修改，只需要重新编译动态库文件，而无需将新生成的动态库和目标程序.out文件重新链接。开发的时候很方便。

## 1. 生成汇编文件

```shell
g++ -fPIC -c -o test.o test.c 	//-c生成汇编文件
```

![image-20211017183901353](https://i.loli.net/2021/10/17/xZrU6kFAS9IopRJ.png)

## 2. 生成库文件

```shell
g++ -shared -o libtest.so test.o 
```

> -shared——表示生成共享库
>
> **libtest.so——共享库文件名是libtest.so，共享库名是test**

## 3. 链接动态库

```shell
g++ -o main.out main.cpp -L./ -ltest
```

***若直接按照该代码执行，将无法链接动态库。与静态库加入到.out文件不同，动态库需要被加载器加载到内存中。而加载器默认只会去/lib或/usr/lib等去搜索动态库。***

![image-20211017210219813](https://i.loli.net/2021/10/17/mc6AF3fiSQdTCZU.png)

![image-20211017210548617](https://i.loli.net/2021/10/17/EvfFQt5XdDUPh8r.png)

库的搜索路径十分重要

```shell
export LD_LIBRARY_PATH="./"
```

![image-20211017210728387](https://i.loli.net/2021/10/17/vCQB6EID3wLaFUj.png)



## 4. 判断程序有没有链接动态库

### （1）file——查看文件类型

```shell
file a.out 
```

![image-20211017210941858](https://i.loli.net/2021/10/17/3k9GutA1sfoUcLZ.png)

![image-20211017211109129](https://i.loli.net/2021/10/17/6GXuY4LZhlaBIqP.png)

### （2）ldd——查看.out文件链接了哪些动态库

```shell
ldd a.out
```

![image-20211017211242186](https://i.loli.net/2021/10/17/kuMRs8dStAX5J1B.png)

> libc.so.6——C函数库
>
> ld_linux-x86-64.so.2——加载器



## 5. g++默认先链接动态库

当同一目录下有**同名**的动态库和静态库，那么编译时会链接哪个库呢？

***g++默认先链接动态库，若需要链接静态库，需要指定-static选项。***

```shell
g++ -o main.out main.cpp -L./ -static -lxxxx
```



## 6. 静态库、动态库混合链接

![image-20211017212023978](https://i.loli.net/2021/10/17/Pi3GA6JflWRtjFn.png)

```shell
-Wl,-Bstatic指定后边跟着的库都是静态方式链接
-Wl,-Bdynamic指定后边跟着的库都是动态方式链接
```



---

# Windows下使用VS2019制作动态库及链接

https://blog.csdn.net/qq_30139555/article/details/103621955

```c++
//用宏定义替代__declspec在头文件中导出dll所需要变量
#define __declspec(dllexport) DLLExport
```

![image-20211018001220538](https://i.loli.net/2021/10/18/qlm85wLtDCz6aku.png)

#### 注意点1：只有main.cpp中要用的函数、变量等才用DLLExport和DLLImport导入导出。库内部用到的所有东西不要导出。

#### 注意点2：DLL本质上是函数库，暴露的是函数接口，所以对于全局变量、类不要直接使用DLLExport的方法

#### 注意点3：导出的接口前除了DLLExport宏还要加上extern "C"，extern "C"可以让比编译器以C方式编译该函数，避免C++方式在编译代码时考虑重载而将函数名与参数名组合改变函数名，导致调用DLL的程序找不到接口函数。

```c++
//hillClimbing.h
#pragma once
#include<iostream>
#include<vector>
#include<string>
#include<fstream>
#include<sstream>
#include<cmath>
#include<time.h>
#include<algorithm>
using namespace std;

#define DLLExport __declspec (dllexport)
#define DLLImport __declspec (dllimport)

DLLExport extern int cityNum;
DLLExport extern int group_size;
DLLExport extern int generation;

//定义个体
 class Chromosome {
public:
	vector<int> gene;
public:
	 Chromosome() {}
	 Chromosome(vector<int>& gene) {
		 this->gene.assign(gene.begin(), gene.end());
	 }
	 ~Chromosome() {}
public:
	double calcFitness(vector<vector<double>>& dis);
};

//读文件，返回坐标向量pos
extern "C" DLLExport vector < pair<double, double> >ReadPosition(const string&);

//返回距离矩阵dis
extern "C" DLLExport vector<vector<double>> Distance(vector<pair<double, double>>&);

//随机初始化初始种群
extern "C" DLLExport vector<Chromosome*> InitGroup();

//返回种群最优个体
Chromosome* best(vector<Chromosome*>& group, vector<vector<double>>&);

//爬山算法
extern "C" DLLExport void ClimbingHill(vector<Chromosome*>& group, vector<vector<double>>& dis, const string& targetPath1, vector<pair<double, double>>& pos);
```

```c++
#include"pch.h"
#include"hillClimbing.h"

int cityNum = 0;
int group_size = 0;
int generation = 0;

//[a,b]范围内随机数
#define RANDOM_INT(a,b) (rand() % (b-a+1))+ a	
//生成0~1随机double数
#define RANDOM_01	(rand())/(RAND_MAX+1.0)

////定义个体
//class Chromosome {
//public:
//	vector<int> gene;
//public:
//	Chromosome() {}
//	Chromosome(vector<int>& gene) {
//		this->gene.assign(gene.begin(), gene.end());
//	}
//	~Chromosome() {}
//public:
//	double calcFitness(vector<vector<double>>& dis) {
//		double sumDis = 0.0;
//		for (unsigned int i = 0; i < cityNum - 1; ++i) {
//			sumDis += dis[this->gene.at(i)][this->gene.at(i + 1)];
//		}
//		sumDis += dis[this->gene.at(cityNum - 1)][this->gene.at(0)];
//		return 1.0 / sumDis;
//	}
//};

//Chromosome::Chromosome(vector<int>& gene) {
//	this->gene.assign(gene.begin(), gene.end());
//}

double Chromosome::calcFitness(vector<vector<double>>& dis)
{
	double sumDis = 0.0;
	for (unsigned int i = 0; i < cityNum - 1; ++i) {
		sumDis += dis[this->gene.at(i)][this->gene.at(i + 1)];
	}
	sumDis += dis[this->gene.at(cityNum - 1)][this->gene.at(0)];
	return 1.0 / sumDis;
}

//读文件，返回坐标向量pos
vector < pair<double, double> >ReadPosition(const string& sourceFilePath) {
	vector<pair<double, double>> pos;
	pos.reserve(cityNum);
	double x = 1.0;
	double y = 1.0;
	string tempX;
	string tempY;
	string tempIndex;
	stringstream ss;
	ifstream ism;
	ism.open(sourceFilePath, ios::in | ios::binary);
	if (!ism) {
		cout << "open file error..." << endl;
	}
	while (!ism.eof()) {
		getline(ism, tempIndex, '\t');
		getline(ism, tempX, '\t');
		ss << tempX;
		ss >> x;
		ss.clear();
		getline(ism, tempY, '\n');
		ss << tempY;
		ss >> y;
		ss.clear();
		pos.push_back(make_pair(x, y));
	}
	ism.close();
	return pos;
}

//返回距离矩阵dis
vector<vector<double>> Distance(vector<pair<double, double>>& pos) {
	vector<vector<double>> dis(cityNum, vector<double>(cityNum));
	for (unsigned int i = 0; i < cityNum; ++i) {
		dis[i][i] = 0;
	}
	for (unsigned int i = 0; i < cityNum; ++i) {
		for (unsigned int j = i + 1; j < cityNum; ++j) {
			dis[i][j] = sqrt((pos[i].first - pos[j].first) * (pos[i].first - pos[j].first) + (pos[i].second - pos[j].second) * (pos[i].second - pos[j].second));
			dis[j][i] = dis[i][j];
		}
	}
	return dis;
}

//随机初始化初始种群
vector<Chromosome*> InitGroup() {
	srand((unsigned int)time(0));
	vector<Chromosome*> group;
	group.reserve(group_size);
	for (unsigned int i = 0; i < group_size; ++i) {
		unsigned int random = RANDOM_INT(0, cityNum - 1);
		vector<int> gene;
		gene.reserve(cityNum);
		gene.push_back(random);
		for (unsigned int j = 1; j < cityNum; ++j) {
			do {
				random = RANDOM_INT(0, cityNum - 1);
			} while (find(gene.begin(), gene.end(), random) != gene.end());	//find未查找到则返回.end()
			gene.push_back(random);
		}
		group.push_back(new Chromosome(gene));
	}
	return group;
}

//返回种群最优个体
Chromosome* best(vector<Chromosome*>& group, vector<vector<double>>& dis) {
	Chromosome* bestTemp = *(group.begin());
	for (vector<Chromosome*>::iterator it = group.begin(); it != group.end(); it++) {
		if ((*it)->calcFitness(dis) > bestTemp->calcFitness(dis)) {
			bestTemp = *it;
		}
	}
	return bestTemp;
}

//爬山算法
void ClimbingHill(vector<Chromosome*>& group, vector<vector<double>>& dis, const string& targetPath1, vector<pair<double, double>>& pos) {
	srand((unsigned int)time(0));
	ofstream osm;
	int random1, random2;
	int gen = 0;
	Chromosome* bestIndividual = NULL;
	while (gen < generation) {
		osm.open(targetPath1, ios::out | ios::app);
		for (vector<Chromosome*>::iterator it = group.begin(); it != group.end(); it++) {
			Chromosome* newIndividual = new Chromosome((*it)->gene);	//构建一个和父代个体gene一样的个体
																		//用交换任意两处gene来描述在当前个体的邻域中搜索的过程
			do {
				random1 = RANDOM_INT(0, cityNum - 1);
				random2 = RANDOM_INT(0, cityNum - 1);
			} while (random1 == random2);
			//交换random1和random2处的gene
			//
			int temp;
			temp = newIndividual->gene.at(random1);
			newIndividual->gene.at(random1) = newIndividual->gene.at(random2);
			newIndividual->gene.at(random2) = temp;
			//判断新个体和父代个体的优劣
			if (newIndividual->calcFitness(dis) > (*it)->calcFitness(dis)) {
				*it = newIndividual;	//替换
			}
		}
		bestIndividual = best(group, dis);
		//输出路径
		/*for (unsigned int i = 0; i < bestIndividual->gene.size(); ++i) {
			osm << bestIndividual->gene.at(i)<<"->";
		}
		osm << '\t';*/
		//输出最优解路程
		double sum = 0;
		for (unsigned int i = 0; i < cityNum - 1; ++i) {
			sum += dis[bestIndividual->gene.at(i)][bestIndividual->gene.at(i + 1)];
		}
		sum += dis[bestIndividual->gene.at(cityNum - 1)][bestIndividual->gene.at(0)];
		osm << sum << endl;
		osm.close();
		cout << gen << endl;
		//输出该代所有个体坐标
		string targetPath2 = "C:\\Users\\25224\\Desktop\\HillClimbing\\data\\Gen\\gen";
		stringstream ss;
		ss << targetPath2 << gen << ".dat";
		targetPath2 = "";
		ss >> targetPath2;
		ss.clear();
		osm.open(targetPath2, ios::out | ios::app);
		for (unsigned int i = 0; i < group.size(); ++i) {
			osm << i << '\t' << 1.0 / (group.at(i)->calcFitness(dis)) << endl;
		}
		osm.close();
		++gen;
	}
}
```

https://blog.csdn.net/a55684471/article/details/102366415

https://blog.csdn.net/Andy710660541/article/details/111196740

#### 注意点4： 不论是普通函数还是类的成员函数，想要暴露出作为接口被其他程序调用都要用DLLExport和DLLImport。成员函数想要能够被调用，仅仅导出导入类是不行的（不导出类，仅仅导出类的成员函数也可以访问public的成员函数）。但是全局变量的话必须要导出，才能被调用的程序访问到。

```c++
//DLL.h
#pragma once
#include<iostream>
#include<vector>
#include<string>
using namespace std;
#define DLLExport  _declspec(dllexport) 
#define DLLImport  _declspec(dllimport) 

DLLExport extern int numVec;	//不能省略DLLExport，否则numVec无法访问。extern表明此处为声明，定义在别的文件处（DLL.cpp处，否则DLL.cpp中的定义会                                 //被看作重定义）

class Person {					//类可以不DLLExport，printName()仍然可以被访问
public:
	Person() {}
	Person(string n) {
		this->name = n;
	}
	string name;
	~Person() {}
public:
	DLLExport void printName();		//Person被DLLExport，若printName不DLLExport，也是不可调用的。PrintName必须要DLLExport
};

extern "C" DLLExport int add(int a, int b);		//extern "C"防止c++的重载机制修改函数名
extern "C" DLLExport int multip(int, int);

extern "C" DLLExport void setNumVec(int val);

extern "C" DLLExport int getNumVec();

//extern "C" DLLExport vector<int> getVec(int);
vector<int> getVec(int);						//getVec不暴露为接口，调用程序中无法访问
extern "C" DLLExport void printVec();
```

```c++
//DLL.cpp
#include"pch.h"
#include"DLL.h"

int numVec = 0;

void Person::printName() {
	cout << "name: " << this->name << endl;
}


int add(int a, int b) {
	return a + b;
}

int multip(int a, int b) {
	return a * b;
}

void setNumVec(int val) {
	numVec = val;
}

int getNumVec() {
	return numVec;
}

vector<int> getVec(int n) {
	vector<int> v;
	v.reserve(n);
	for (int i = 0; i < n; i++) {
		v.push_back(i);
	}
	return v;
}

void printVec() {
	vector<int> tempv = getVec(numVec);
	for (auto it = tempv.begin(); it != tempv.end(); it++) {
		cout << *it << endl;
	}
}
```

```c++
//main工程中的DLL.h
//调用程序将DLL.h添加到自己项目的头文件文件夹中，将DLLExport改为DLLImport表明将接口从库文件中导入
#pragma once
#pragma comment(lib, "Dlltest.lib")		//导入库文件

#include<iostream>
#include<vector>
#include<string>
using namespace std;
#define DLLExport  _declspec(dllexport) 
#define DLLImport  _declspec(dllimport) 

DLLImport extern int numVec;	//导入全局变量

class Person {
public:
	Person() {}
	Person(string n) {
		this->name = n;
	}
	string name;
	~Person() {}
public:
	DLLImport void printName();	//导入成员函数
};

extern "C" DLLImport int add(int a, int b);
extern "C" DLLImport int multip(int, int);

extern "C" DLLImport void setNumVec(int val);

extern "C" DLLImport int getNumVec();

//extern "C" DLLExport vector<int> getVec(int);
vector<int> getVec(int);
extern "C" DLLImport void printVec();
```

```c++
//main.cpp
#include"DLL.h"

int main(int argc, char** argv) {
	cout << "sum=	" << add(2, 3);
	cout << "multi=   " << multip(2, 3);
	numVec = 10;
	printVec();
	
	Person p("wang");
	p.printName();
	return 0;
}
```

