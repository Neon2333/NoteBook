# Part 00——注意点收集



## 1. vs code编译报错`__imp_WASartup`等的解决办法

![image-20210827231215022](https://i.loli.net/2021/08/27/mElYtpyM84CV2eU.png)

https://blog.csdn.net/qq_20916555/article/details/50938424

https://www.yht7.com/news/127552

## 2. 127.0.0.1——回送地址

127.0.0.1是回送地址（loopback address），替代当前计算机的IP。

---

# Part 01——C# winform Socket



## 1. DNS解析

### 头文件——System.Net

### （1）主机类——IPHostEntry

* 服务器主机信息的容器，将服务器的URI、IP地址列表（一个URI可能对应好几台服务器，因此也就有好几个IP）、一组别名相关联并封装。

```c#
IPHostEntry hostInfo = Dns.GetHostEntry("www.bing.com");	//将uri "www.bing.com"经过DNS解析，返回存储着主机信息的	//IPHostEntry实例
```

#### 属性

> * AddressList——获取/设置主机的IP地址列表
>
>   ```C#
>   public IPAddress[] AddressList	{get; set;}
>   ```
>  
>     ```c#
>   // Get 'IPHostEntry' object containing information like host name, IP addresses, aliases for a host.
>           IPHostEntry hostInfo = Dns.GetHostByName(hostString);
>           Console.WriteLine("Host name : " + hostInfo.HostName);
>           Console.WriteLine("IP address List : ");
>           for(int index=0; index < hostInfo.AddressList.Length; index++)
>           {
>               Console.WriteLine(hostInfo.AddressList[index]);
>           }
>     ```
>   
> * HostName——获取主机的DNS名称/URI
>
>   ```C#
>  public string HostName { get; set; }
>   ```
> 
> * Aliases——获取主机别名
>
>   ```c#
>    public string[] Aliases { get; set; }
>   ```

### （2）IP地址类——IPAddress

获取服务器的IP地址相关信息。

Tostring()转化为点分十进制形式的IP。

#### 属性

> * Address——十进制形式IP（已过时）
> * AddressFamily——IP地址使用的地址族

### （3）Dns类

该类提供简单的DNS解析功能。

#### 方法

> * GetHostEntry(string)——将**主机名或 IP 地址**解析为IPHostEntry实例。（Resolve已过时）
>
> * GetHostName()——获取本地计算机主机名
>
> * GetHostAddresses(string)——返回指定主机的 Internet 协议 (IP) 地址
>
>   ```c#
>   public static System.Net.IPAddress[] GetHostAddresses (string hostNameOrAddress);
>   ```
>
> * BeginGetHostEntry(String, AsyncCallback, Object)——将主机名或 IP 地址**异步**解析为IPHostEntry实例
>
>   ```C#
>   public static IAsyncResult BeginGetHostEntry (string hostNameOrAddress, AsyncCallback? requestCallback, object? stateObject);
>   ```

```c#
 private void button_addrEx_Click(object sender, EventArgs e)
        {
            IPHostEntry host = Dns.GetHostEntry(textBox_uri.Text);
            //foreach(IPAddress addr in host.AddressList)
            //{
            //    long ip = addr.Address;
            //    textBox_ip.Text += ip.ToString() + "\r\n";
            //    textBox_ip.Text += addr.ToString() + "\r\n";
            //}
            textBox_host.Text = host.HostName;
            IPAddress[] ips= Dns.GetHostAddresses(textBox_uri.Text);
            foreach(IPAddress addr in ips)
            {
                long ip = addr.Address;
                textBox_ip.Text += ip.ToString() + "\r\n";	//Windows中换行符是\r\n
                textBox_ip.Text += addr.ToString() + "\r\n";
            }
        }
```



## 2. TCP

### （1）头文件——System.Net.Sockets

### （2）NetworkStream类——为网络访问提供数据的基础流

#### 构造

```C#
public NetworkStream (Socket socket);
```

```C#
public NetworkStream (Socket socket, bool ownsSocket);
/*
Socket
Socket，NetworkStream 使用它来发送和接收数据。
ownsSocket
Boolean
设置为 true 可指示 NetworkStream 将拥有 Socket；否则为 false。
*/
```

```C#
// Examples for constructors that do not specify file permission.

// Create the NetworkStream for communicating with the remote host.
NetworkStream myNetworkStream;

if (networkStreamOwnsSocket){
     myNetworkStream = new NetworkStream(mySocket, true);
}
else{
     myNetworkStream = new NetworkStream(mySocket);
}
```

#### 方法

> * Read——从NetworkStream读取数据，并将其存储到字节数组中
>
>   ```C# 
>   public override int Read (byte[] buffer, int offset, int size);
>   ```
>
>   > - buffer——Byte类型的数组，它是内存中用于存储从NetworkStream读取的数据的位置。
>   >
>   > - offset——buffer 中数据存储的起始位置
>   >
>   > - size——要从中读取的字节数
>   > - 返回值——从NetworkStream中实际读取的字节数
>
> * Write——从字节数组的指定范围向NetworkStream写入数据
>
>   ```C#
>   public override void Write (byte[] buffer, int offset, int size);
>   ```
>
>   > * buffer——存储要写入流的数据
>   > * offset——buffer要写入数据的起始位置
>   > * size——buffer要写入字节长度
>
> * ReadByte——从NetworkStream中读取一个字节，并将流内的位置向前提升一个字节，或者如果已到达流结尾，则返回 -1
>
>   ```C#
>   public override int ReadByte ();
>   ```
>
> * WriteByte——将一个字节写入 NetworkStream内的当前位置，并将流内的位置向前提升一个字节
>
>   ```C#
>   public override void WriteByte (byte value);	//value要写入流当前位置的一个字节
>   ```

#### 属性

> * Length
> * Socket

### （3）TcpClient类——提供客户端连接

#### 构造

```C#
public TcpClient (string hostname, int port);	//初始化 TcpClient 类的新实例并连接到指定主机上的指定端口。
```

> - hostname——要连接到的远程主机的 DNS 名。
>
> - port——要连接到的远程主机的端口号。

```C#
//Creates a TCPClient using host name and port.
TcpClient tcpClientB = new TcpClient ("www.contoso.com", 11000);
```

#### 方法

> * Connect——客户端连接到指定IP和端口的远程主机
>
>   ```C#
>   public void Connect (System.Net.IPAddress address, int port);
>   ```
>
>   > IPAddress——你打算连接到的主机的 IPAddress。
>   > port——要连接到的端口号。
>
>   ```C#
>   public void Connect (System.Net.IPAddress[] ipAddresses, int port);
>   ```
>
>   > ipAddresses——要连接到的主机的 IPAddress 数组。
>   > port——要连接到的端口号。
>
>   ```C#
>   //Uses the IP address and port number to establish a socket connection.
>   TcpClient tcpClient = new TcpClient ();
>   IPAddress ipAddress = Dns.GetHostEntry ("www.contoso.com").AddressList[0];
>           
>   tcpClient.Connect (ipAddress, 11003);
>   ```
>
>   
>
> * GetStream——返回用于发送/接收数据的NetworkStream
>
>   ```C#
>   public System.Net.Sockets.NetworkStream GetStream ();
>   ```
>
>   ```C#
>   TcpClient tcpClient = new TcpClient ();
>           
>   // Uses the GetStream public method to return the NetworkStream.
>   NetworkStream netStream = tcpClient.GetStream ();
>           
>   if (netStream.CanWrite)
>   {
>       Byte[] sendBytes = Encoding.UTF8.GetBytes ("Is anybody there?");
>       netStream.Write (sendBytes, 0, sendBytes.Length);
>   }
>   else
>   {
>       Console.WriteLine ("You cannot write data to this stream.");
>       tcpClient.Close ();
>           
>       // Closing the tcpClient instance does not close the network stream.
>       netStream.Close ();
>       return;
>   }
>           
>   if (netStream.CanRead)
>   {
>       // Reads NetworkStream into a byte buffer.
>       byte[] bytes = new byte[tcpClient.ReceiveBufferSize];
>           
>       // Read can return anything from 0 to numBytesToRead.
>       // This method blocks until at least one byte is read.
>       netStream.Read (bytes, 0, (int)tcpClient.ReceiveBufferSize);
>           
>       // Returns the data received from the host to the console.
>       string returndata = Encoding.UTF8.GetString (bytes);
>           
>       Console.WriteLine ("This is what the host returned to you: " + returndata);
>   }
>   else
>   {
>       Console.WriteLine ("You cannot read data from this stream.");
>       tcpClient.Close ();
>           
>       // Closing the tcpClient instance does not close the network stream.
>       netStream.Close ();
>       return;
>   }
>   netStream.Close();
>   ```
>
>   
>
> * Close——释放TCPClient实例，不关闭TCP连接
>
>   ```c#
>   public void Close ();
>   ```

```C#
static void Connect(String server, String message)
{
  try
  {
    // Create a TcpClient.
    // Note, for this client to work you need to have a TcpServer
    // connected to the same address as specified by the server, port
    // combination.
    Int32 port = 13000;
    TcpClient client = new TcpClient(server, port);

    // Translate the passed message into ASCII and store it as a Byte array.
    Byte[] data = System.Text.Encoding.ASCII.GetBytes(message);

    // Get a client stream for reading and writing.
   //  Stream stream = client.GetStream();

    NetworkStream stream = client.GetStream();

    // Send the message to the connected TcpServer.
    stream.Write(data, 0, data.Length);

    Console.WriteLine("Sent: {0}", message);

    // Receive the TcpServer.response.

    // Buffer to store the response bytes.
    data = new Byte[256];

    // String to store the response ASCII representation.
    String responseData = String.Empty;

    // Read the first batch of the TcpServer response bytes.
    Int32 bytes = stream.Read(data, 0, data.Length);	//bytes是从stream中实际读取的字节数
    responseData = System.Text.Encoding.ASCII.GetString(data, 0, bytes);
    Console.WriteLine("Received: {0}", responseData);

    // Close everything.
    stream.Close();
    client.Close();
  }
  catch (ArgumentNullException e)
  {
    Console.WriteLine("ArgumentNullException: {0}", e);
  }
  catch (SocketException e)
  {
    Console.WriteLine("SocketException: {0}", e);
  }

  Console.WriteLine("\n Press Enter to continue...");
  Console.Read();
}
```



### （4）TCPListener类——服务器端监听

在指定的本地IP和端口号上监听客户端的连接

#### 构造

```C#
public TcpListener (System.Net.IPAddress localaddr, int port);
```

> localaddr——本地IP
>
> port——监听的端口

```C#
TcpListener server=null;
Int32 port = 13000;
IPAddress localAddr = IPAddress.Parse("127.0.0.1");
server = new TcpListener(localAddr, port);
```



#### 方法

> * Start——服务器端启动监听客户端的连接请求
>
>   ```c#
>   public void Start ();
>   ```
>
> * Stop——关闭监听
>
>   ```C#
>   public void Stop ();
>   ```
>
> * AcceptSocket——接受客户端的连接请求，并返回用于收发数据的Socket
>
>   需要先Start监听
>
>   ```C#
>   public System.Net.Sockets.Socket AcceptSocket ();	
>   ```
>
>   ```C#
>   // Accepts the pending client connection and returns a socket for communciation.
>              Socket socket = tcpListener.AcceptSocket();
>              Console.WriteLine("Connection accepted.");
>
>              string responseString = "You have successfully connected to me";
>
>              //Forms and sends a response string to the connected client.
>              Byte[] sendBytes = Encoding.ASCII.GetBytes(responseString);
>              int i = socket.Send(sendBytes);
>              Console.WriteLine("Message Sent /> : " + responseString);
>   ```
>
> * AccecptTcpClient——接受挂起的客户端连接请求
>
>   ```C#
>   public System.Net.Sockets.TcpClient AcceptTcpClient ();
>   ```
>
>   > 返回值——TcpClient 
>
>   ```C#
>   /**
>   * The following sample is intended to demonstrate how to use a
>   * TcpListener for synchronous communcation with a TCP client
>   * It creates a TcpListener that listens on the specified port (13000).
>   * Any TCP client that wants to use this TcpListener has to explicitly connect
>   * to an address obtained by the combination of the server
>   * on which this TcpListener is running and the port 13000.
>   * This TcpListener simply echoes back the message sent by the client
>   * after translating it into uppercase.
>   * Refer to the related client in the TcpClient class.
>   */
>   using System;
>   using System.Text;
>   using System.IO;
>   using System.Net;
>   using System.Net.Sockets;
>   using System.Threading;
>         
>   public class TcpListenerSample
>   {
>         
>       static void Main(string[] args)
>       {
>           try
>           {
>               // set the TcpListener on port 13000
>               int port = 13000;
>               TcpListener server = new TcpListener(IPAddress.Any, port);
>         
>               // Start listening for client requests
>               server.Start();
>         
>               // Buffer for reading data
>               byte[] bytes = new byte[1024];
>               string data;
>         
>               //Enter the listening loop
>               while (true)
>               {
>                   Console.Write("Waiting for a connection... ");
>         
>                   // Perform a blocking call to accept requests.
>                   // You could also use server.AcceptSocket() here.
>                   TcpClient client = server.AcceptTcpClient();
>                   Console.WriteLine("Connected!");
>         
>                   // Get a stream object for reading and writing
>                   NetworkStream stream = client.GetStream();
>         
>                   int i;
>         
>                   // Loop to receive all the data sent by the client.
>                   i = stream.Read(bytes, 0, bytes.Length);
>         
>                   while (i != 0)
>                   {
>                       // Translate data bytes to a ASCII string.
>                       data = System.Text.Encoding.ASCII.GetString(bytes, 0, i);
>                       Console.WriteLine(String.Format("Received: {0}", data));
>         
>                       // Process the data sent by the client.
>                       data = data.ToUpper();
>         
>                       byte[] msg = System.Text.Encoding.ASCII.GetBytes(data);
>         
>                       // Send back a response.
>                       stream.Write(msg, 0, msg.Length);
>                       Console.WriteLine(String.Format("Sent: {0}", data));
>         
>                       i = stream.Read(bytes, 0, bytes.Length);
>                   }
>         
>                   // Shutdown and end connection
>                   client.Close();
>               }
>           }
>           catch (SocketException e)
>           {
>               Console.WriteLine("SocketException: {0}", e);
>           }
>         
>           Console.WriteLine("Hit enter to continue...");
>           Console.Read();
>       }
>   }
>   ```
>
> 

```C#
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;

class MyTcpListener
{
  public static void Main()
  {
    TcpListener server=null;
    try
    {
      // Set the TcpListener on port 13000.
      Int32 port = 13000;
      IPAddress localAddr = IPAddress.Parse("127.0.0.1");

      // TcpListener server = new TcpListener(port);
      server = new TcpListener(localAddr, port);

      // Start listening for client requests.
      server.Start();

      // Buffer for reading data
      Byte[] bytes = new Byte[256];
      String data = null;

      // Enter the listening loop.
      //循环接收客户端的连接请求
      while(true)
      {
        Console.Write("Waiting for a connection... ");

        // Perform a blocking call to accept requests.
        // You could also use server.AcceptSocket() here.	也可使用server.AcceptSocket()
        TcpClient client = server.AcceptTcpClient();	//阻塞，等待客户端连接
        Console.WriteLine("Connected!");

        data = null;

        // Get a stream object for reading and writing
        NetworkStream stream = client.GetStream();

        int i;

        // Loop to receive all the data sent by the client.
        while((i = stream.Read(bytes, 0, bytes.Length))!=0)
        {
          // Translate data bytes to a ASCII string.
          data = System.Text.Encoding.ASCII.GetString(bytes, 0, i);
          Console.WriteLine("Received: {0}", data);	//显示从服务器接受的数据

          // Process the data sent by the client.
          data = data.ToUpper();

          byte[] msg = System.Text.Encoding.ASCII.GetBytes(data);

          // Send back a response.
          stream.Write(msg, 0, msg.Length);	
          Console.WriteLine("Sent: {0}", data);	//将从服务器接收的字符串，变为大写，发送回服务器
        }

        // Shutdown and end connection
        client.Close();
      }
    }
    catch(SocketException e)
    {
      Console.WriteLine("SocketException: {0}", e);
    }
    finally
    {
       // Stop listening for new clients.
       server.Stop();
    }

    Console.WriteLine("\nHit enter to continue...");
    Console.Read();
  }
}
```



### （5）Socket类

不同主机间的进程进行互相通信的端点。通信时至少需要一对socket，一个在客户端一个在服务端，一个Socket类实例包含了客户端端点或服务器端点的socket信息

### 构造

```C#
public Socket (AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
```

> * addressFamily——地址族
>
>   > AddressFamily——enum
>   >
>   > * InterNetwork——IPv4
>   > * InterNetworkV6——IPv6
>
>   ```C#
>   using System;
>   using System.Text;
>   using System.IO;
>   using System.Net;
>   using System.Net.Sockets;
>       
>   public class Sample
>   {
>       
>     public static string DoSocketGet(string server)
>     {
>       //Set up variables and String to write to the server.
>       Encoding ASCII = Encoding.ASCII;
>       string Get = "GET / HTTP/1.1\r\nHost: " + server +
>                    "\r\nConnection: Close\r\n\r\n";
>       Byte[] ByteGet = ASCII.GetBytes(Get);
>       Byte[] RecvBytes = new Byte[256];
>       String strRetPage = null;
>       
>       // IPAddress and IPEndPoint represent the endpoint that will
>       //   receive the request.
>       // Get first IPAddress in list return by DNS.
>       
>       try
>       {
>       
>         // Define those variables to be evaluated in the next for loop and
>         // then used to connect to the server. These variables are defined
>         // outside the for loop to make them accessible there after.
>         Socket s = null;
>         IPEndPoint hostEndPoint;
>         IPAddress hostAddress = null;
>         int conPort = 80;
>       
>         // Get DNS host information.
>         IPHostEntry hostInfo = Dns.GetHostEntry(server);
>         // Get the DNS IP addresses associated with the host.
>         IPAddress[] IPaddresses = hostInfo.AddressList;
>       
>         // Evaluate the socket and receiving host IPAddress and IPEndPoint.
>         for (int index=0; index<IPaddresses.Length; index++)
>         {
>           hostAddress = IPaddresses[index];
>           hostEndPoint = new IPEndPoint(hostAddress, conPort);	//构造IPEndPoint
>   
>   
>           // Creates the Socket to send data over a TCP connection.
>           s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp );
>   
>   
>           // Connect to the host using its IPEndPoint.
>           s.Connect(hostEndPoint);
>           
>           if (!s.Connected)
>           {
>             // Connection failed, try next IPaddress.
>             strRetPage = "Unable to connect to host";
>             s = null;
>             continue;
>           }
>           
>           // Sent the GET request to the host.
>           s.Send(ByteGet, ByteGet.Length, 0);
>           
>         } // End of the for loop.
>   
>   
>         // Receive the host home page content and loop until all the data is received.
>         Int32 bytes = s.Receive(RecvBytes, RecvBytes.Length, 0);
>         strRetPage = "Default HTML page on " + server + ":\r\n";
>         strRetPage = strRetPage + ASCII.GetString(RecvBytes, 0, bytes);
>           
>         while (bytes > 0)
>         {
>           bytes = s.Receive(RecvBytes, RecvBytes.Length, 0);
>           strRetPage = strRetPage + ASCII.GetString(RecvBytes, 0, bytes);
>         }
>           
>       } // End of the try block.
>           
>       catch(SocketException e)
>       {
>         Console.WriteLine("SocketException caught!!!");
>         Console.WriteLine("Source : " + e.Source);
>         Console.WriteLine("Message : " + e.Message);
>       }
>       catch(ArgumentNullException e)
>       {
>         Console.WriteLine("ArgumentNullException caught!!!");
>         Console.WriteLine("Source : " + e.Source);
>         Console.WriteLine("Message : " + e.Message);
>       }
>       catch(NullReferenceException e)
>       {
>         Console.WriteLine("NullReferenceException caught!!!");
>         Console.WriteLine("Source : " + e.Source);
>         Console.WriteLine("Message : " + e.Message);
>       }
>       catch(Exception e)
>       {
>         Console.WriteLine("Exception caught!!!");
>         Console.WriteLine("Source : " + e.Source);
>         Console.WriteLine("Message : " + e.Message);
>       }
>           
>       return strRetPage;
>   }
>      public static void Main()
>      {
>         Console.WriteLine(DoSocketGet("localhost"));
>      }
>    }
>   ```
>   
>   * socketType——socket类型
>   
>     > * SocketType——enum
>     > * Dgram——数据报socket
>     > * Stream——流socket
>
>   ```C#
>   //Creates the Socket for sending data over TCP.
>   Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Stream,
>      ProtocolType.Tcp );
> 
>   // Connects to host using IPEndPoint.
>   s.Connect(EPhost);
>   if (!s.Connected)
>   {
>      strRetPage = "Unable to connect to host";
>   }
>   // Use the SelectWrite enumeration to obtain Socket status.
>    if(s.Poll(-1, SelectMode.SelectWrite)){
>         Console.WriteLine("This Socket is writable.");
>    }
>    else if (s.Poll(-1, SelectMode.SelectRead)){
>          Console.WriteLine("This Socket is readable." );
>    }
>    else if (s.Poll(-1, SelectMode.SelectError)){
>         Console.WriteLine("This Socket has an error.");
>    }
>   ```
>
> 
>
> * [protocolType](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.protocoltype?view=net-5.0)——协议
>
>   > * ProtocolType——enum
>   > * IPv4
>   > * IPv6
>   > * Tcp
>   > * Udp
>   > * Icmp
>   > * Igmp

#### 方法

> * 



## 3. HTTP——Web服务器

### （1）WebClient

提供将数据发送到指定Uri和从指定Uri获取数据的方法

```C#
WebClient client = new WebClient();
Stream data = client.OpenRead(textBoxUri.Text);
StreamReader reader = new StreamReader(data);
textBox_content.Text = reader.ReadtoEnd();
reader.close();
data.close();
```

### （2）WebRequest



### （3）WebResponse



### （4）浏览器控件

![image-20210913223432788](https://i.loli.net/2021/09/13/5X7Ioh4H9jmTbzP.png)

```c#
 private void button1_Click(object sender, EventArgs e)
 {
 	webBrowser1.Navigate(textBox_searchUri.Text, false);
 }
```

![image-20210914195241060](https://i.loli.net/2021/09/14/nCKRIspNy159MJr.png)

---

# Part 02——C/C++ Socket

[Socket技术详解](https://www.jianshu.com/p/066d99da7cbd)

## 1. 文件IO和ANSI标准IO

https://blog.csdn.net/owen7500/article/details/53263981

文件IO——OS提供的底层IO，没有缓冲

标准IO——封装了缓冲机制，调用OS底层IO的IO

---

## 2. server--->client的基本流程

### Linux

#### （1）server

> ##### 创建套接字——socket
>
> ```c
> //Linux
> #include<stdlib.h>
> #include<stdio.h>
> #include<sys/socket.h>
> int socket(int domain, int type, int protocol);	//成功返回文件描述符fd，失败返回-1
> ```
>
> ```c
> int fd = socket(PF_INET, SOCK_DGRAM, 0);
> ```
>
> ##### 套接字绑定地址——bind
>
> ```c
> //Linux
> #include<sys/socket.h>
> int bind(int sock, struct sockaddr* server_addr, socklen_t addrlen);	//成功返回0，失败返回-1
> ```
>
> ```c
> struct sockaddr_in serv_addr;	//定义server地址为sockaddr_in类型
> memset(&serv_addr,0,sizeof(serv_addr));	//置0
> serv_addr.sin_family=AF_INET;	//IPv4
> serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);	//绑定IP地址，INADDR_ANY表示所有网卡的IP
> serv_addr.sin_port=htons(atoi(argv[1]));	//命令行第2个参数为server监听的端口
> if(bind(sock,(struct sockaddr*)&serv_addr, sizeof(serv_addr))==-1){
>  serv_bindHandling();
> }
> ```
>
> * **INADDR_ANY**
>
> > NADDR_ANY
> > 转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。
> > 比如一台电脑有3块网卡，分别连接三个网络，那么这台电脑就有3个ip地址了，如果某个应用程序需要监听某个端口，那他要监听哪个网卡地址的端口呢？
> >
> > 如果绑定某个具体的ip地址，你只能监听你所设置的ip地址所在的网卡的端口，其它两块网卡无法监听端口，如果我需要三个网卡都监听，那就需要绑定3个ip，也就等于需要管理3个套接字进行数据交换，这样岂不是很繁琐？
> >
> > 所以出现INADDR_ANY，你只需绑定INADDR_ANY，管理一个套接字就行，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
>
> * **htonl——将主机的32位无符号长整形数转换成网络字节顺序**
>
> ```c
> uint32_t htonl(uint32_t hostlong);
> ```
>
> * **htons——将主机的16位无符号短整形数转换成网络字节顺序**
>
> ```c
> uint16_t htonl(uint16_t hostshort);
> ```
>
> * **atoi——把字符串转成整型数，跳过空字符。字符不能转成int或空字符时，无法转换时返回0。**
>
> ```c
> int atoi(const char *nptr); 
> ```
>
> **网络字节序**
>
> > 所谓网络字节顺序（大尾顺序）就是指一个数在内存中存储的时候“高对低，低对高”（即一个数的高位字节存放于低地址单元，低位字节存放在高地址单元中）。但是计算机的内存存储数据时有可能是大尾顺序或者小尾顺序。
> >
> > 先举个例子：
> > int a = 0x403214;
> > int b = htonl(a);
> > 我在VC++6.0调试这段代码，发现
> > &a的值为：0x0012ff44
> > 其中0x0012ff44、0x0012ff45、0x0012ff46、0x0012ff47这四个单元的值依次为：14、32、40、00，即0x403214这个数的高位部分存放在高位地址中，低位部分存放在低位地址中，即小尾顺序。
> > &b的值为：0x0012ff40
> > 其中0x0012ff40、0x0012ff41、0x0012ff42、0x0012ff43这四个单元的值依次为：00、40、32、14，即把原数0x403214的高位部分存放在低位地址中，低位部分存放在高位地址中。
> > 由此可见，如果一个数以小尾顺序存储，经htonl函数调用后这个数的高地位字节会完全颠倒过来成为一个新的数。这个新的数在机器内部其实还是以小尾顺序存储的，但是相对于原来的数而言相当于是变成大尾顺序的了。
> > long型的0x40写完整为:0x 00 00 00 40，共四个字节，调用htonl后四个字节颠倒顺序，为0x 40 00 00 00。
> > 同样，0x40 00 00 00调用htonl后变为0x 00 00 00 40，即0x40
>
> * 转为监听状态——Listen
>
>   ```c
>   //Linux
>   #include<sys/socket.h>
>   int listen(int sock, int backlog);	//成功返回0，失败返回-1
>   ```
>
>   > backlog——服务器接受的请求队列的长度。当有多个客户端同时请求时，服务端无法对所有进行处理，设置队列将请求放入其中，backlog设置队列长度。backlog=10，若来20个请求，则后面10个会被server拒绝不会给对应的client发送rst，这10个client将继续发送TCP SYN，带队列中有请求通过三次握手建立了TCP连接将会从队列中移到另一个队列中。空出位置才能供后续请求移入。
>
> * 阻塞接收消息——accept
>
>   ```c
>   //Linux
>   #include<sys/socket.h>
>   int accept(int sock, struct sockaddr* client_addr, socklen_t* addrlen);	//成功返回文件描述符fd，失败返回-1
>   ```
>
>   ```c
>   struct sockaddr_in serv_addr;
>   int clnt_addr_size = sizeof(clnt_addr);
>   if(accept(sock,(struct sockaddr_in*)&clnt_addr, &clnt_addr_size)==-1){
>       serv_acceptHandling();
>   }
>   ```
>
>   ```c++
>   //message_server.cpp
>                                       
>   ```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(char *message);

int main(int argc, char *argv[])
{
	int serv_sock;
	int clnt_sock;

	struct sockaddr_in serv_addr;
	struct sockaddr_in clnt_addr;
	socklen_t clnt_addr_size;

	char message[]="Hello World!";
	
	if(argc!=2){
		printf("Usage : %s <port>\n", argv[0]);
		exit(1);
	}
	
	serv_sock=socket(PF_INET, SOCK_STREAM, 0);
	if(serv_sock == -1)
		error_handling("socket() error");
	
	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family=AF_INET;
	serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);
	serv_addr.sin_port=htons(atoi(argv[1]));
	
	if(bind(serv_sock, (struct sockaddr*) &serv_addr, sizeof(serv_addr))==-1 )
		error_handling("bind() error"); 
	
	if(listen(serv_sock, 5)==-1)
		error_handling("listen() error");
	
	clnt_addr_size=sizeof(clnt_addr);  
	clnt_sock=accept(serv_sock, (struct sockaddr*)&clnt_addr,&clnt_addr_size);
	if(clnt_sock==-1)
		error_handling("accept() error");  
	
	write(clnt_sock, message, sizeof(message));
	close(clnt_sock);	
	close(serv_sock);
	return 0;
}

void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```



#### （2）client

> * 创建套接字
>
> * 连接server——connect
>
>   ```c
>   //Linux
>   struct sockaddr_in serv_addr;
>   memset(&serv_addr,0,sizeof(serv_addr));
>   
>   serv_addr.sin_family=AF_INET;
>   serv_addr.sin_addr.s_addr=inet_addr(argv[1]);	//server这里是htonl(INADDR_ANY)
>   serv_addr.sin_port=htons(atoi(argv[2]));
>   
>   int connect(int sock, struct sockaddr* server_addr,socklen_t addrlen);	//成功返回0，失败返回-1
>   ```
>
> * 读写数据——IO
>
>   ```c
>   //打开文件
>   #include<sys/types.h>
>   #include<sys/stat.h>
>   #include<fcntl.h>
>   int open(const char* filePath, int flag);	//成功返回文件描述符fd，失败返回-1
>   ```
>
>   > flag——打开模式
>   >
>   > ![image-20210821220713441](https://i.loli.net/2021/08/21/Ehwz9ZHdvrbUeDa.png)
>
>   ```c
>   //关闭文件
>   //关闭文件、套接字都是该函数
>   #include<unistd.h>
>   int close(int fd)	//成功返回0，失败返回-1
>   ```
>
>   ```c
>   //写入文件
>   #include<unistd.h>
>   ssize_t write(int fd, const void* buf, size_t nbytes);	//成功返回写入的字节数，失败返回-1
>   //size_t是由typedef定义的unsigned int，ssize_t是signed int
>   ```
>
>   > fd——文件描述符
>   >
>   > buf——缓存待写入数据的内存
>   >
>   > nbytes——要写入的数据的字节数
>
>   ```c
>   int fd = open("C:\\Users\\25224\\Desktop\\test.dat",O_RDONLY|O_APPEND);
>   if(fd==-1){
>       open_handling();
>   }
>   const char buf[]="this is a open file test..";
>   if(write(fd, buf, sizeof(buf))==-1){
>       write_handling();
>   }
>   close(fd);
>   ```
>
>   ```c
>   //读取文件
>   #include<unistd.h>
>   ssize_t read(int fd, void* buf, size_t nbytes);	//成功返回读取的字节数，失败返回-1
>   ```
>
>   > fd——文件描述符
>   >
>   > buf——保存读取数据的内存
>   >
>   > nbytes——读取的最大字节数
>
>   ```c
>   #define BUF_SIZE 100;
>   int fd = open("C:\\Users\\25224\\Desktop\\test.dat",O_RDONLY);
>   if(fd==-1){
>       open_handling();
>   }
>   char buf[BUF_SIZE]={0};
>   if(read(fd, buf, sizeof(buf))==-1){
>       read_handling();
>   }
>   ```
>
>   ```c++
>   //message_client.cpp
>                               
>   ```
>
> 

### Windows

#### （1）server

```c
//Windows
#include<winsock2.h>
SOCKET socket(int af, int type, int protocol);	//失败返回INVALID_SOCKET
```

```c
//Windows
#include<winsock2.h>
int bind(SOCKET s, const struct sockaddr* name, int namelen);	//成功返回0，失败返回SOCKET_ERROR
```

```c
//Windows
int listen(SOCKET s, int backlog);	//成功返回0，失败返回SOCKET_ERROR
```

```c
//Windows
SOCKET accept(SOCKET s, struct sockaddr* server_addr, int* addrlen);	//成功返回套接字句柄，失败返回INVALID_SOCKET
```

#### （2）client

```c
//Windows
int connect(SOCKET s, const struct sockaddr* name, int namelen);	//成功返回0,，失败返回SOCKET_ERROR
```

#### （3）Windows和Linux区别

* Linux中文件和套接字都用文件描述符描述。Windows中分别用文件句柄和套接字句柄描述。

* 关闭socket

  ```c
  //Linux
  sock.close();	//同文件关闭
  //Windows
  closesocket(sock)	//socket关闭函数
  ```

* Windows使用ws2_32.lib库。定义套接字前，需要初始化库。程序结束前，需将库归还OS，之后无法调用socket函数

  ```c
  #include<winsock2.h>
  int WSAStartup(WROD versionWinsock, WSADATA* lpWSAData);	//成功时返回0
  ......
  int WSACleanup();	//成功返回0，失败返回SOCKET_ERROR
  ```

  > versionWinsock——winsock的版本号，通过MAKEWORD函数方便生成版本号，如主版本1副版本2，MAKEWORD(1, 2)生成0x0201，高位为副版本号

  ```c
  int main(int argc, int argv[]){
      WSADATA wsaData;
      if(WSAStartup(MAKEWORD(2,2),&wsaData)!=0){
          Error_handling("WSAStartup error");
      }
      return 0;
  }
  ```

* 两平台函数名、参数名都相同，只是返回值类型使用不同，需关注。

  > Linux——返回int值，保存文件描述符。错误返回-1
  >
  > ```c
  > SOCKET soc = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
  > if(soc == -1){
  >  ErrorHandling();
  > }
  > ```
  >
  > Win——返回值结构体SOCKET，保存整数型套接字句柄值（本质也是int，为了扩展性定义为SOCKET）.错误返回INVALID_SOCKET
  >
  > ```c
  > SOCKET soc = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
  > if(soc == INVALID_SOCKET){
  >  ErrorHandling();
  > }
  > ```

---

## 3. 创建套接字

### （1）socket函数

```c
//创建socket，此时尚且未分为sock_serv或sock_clnt
//经过bind、listen后的转为sock_serv，经过accecpt的转为sock_clnt
#include<sys/socket.h>
int socket(int domain, int type ,int protocol);	//失败时：-1
```

> domain——协议族
>
> > PF_INET——IPv4
> >
> > PF_INET——IPv6
>
> type——数据传输方式（某个协议族中有多种数据传输方式）
>
> > SOCK_STREAM——面向连接、可靠、有序传输、流量控制、多次发送一次读取
> >
> > SOCK_DGRAM——无连接、不可靠、高速传输、一次发送对应一次读取
>
> protocol——指定具体协议（一般置0，若某协议族中同样数据传输方式的协议有多个，则需要指定具体是哪个协议）
>
> > IPPROTO_TCP
> >
> > IPPROTO_UDP

### （2）Linux建立TCP套接字

```c
/**
*tcp_client.c
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(char* message) {
	printf("%s\n", message);
}

int main(int argc, char* argv[])
{
	int sock;
	struct sockaddr_in serv_addr;
	char message[30];
	int str_len = 0;
	int idx = 0, read_len = 0;

	if (argc != 3) {
		printf("Use: %s<IP> <port>\n", argv[0]);	//若执行程序的命令行参数不是3，则打印格式："tcp_client <IP> <port>"
		exit(l);
	}

	sock = socket(PF_ INET, SOCK_STREAM, 9);
	if (sock == -1)
		error_handling("socket() error");

	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = inet_addr(argv[1]]);	//从命令行参数中取出IP地址
	serv_add.sin_port = htons(atoi(argv[2]));	//从命令行参数中取出端口
	if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {
		error_handling("connect error");
	}
	while (read_len = read(sock, &message[idx++], 1)) {
		if (read_len == -1) {
			error_handling("read error");
		}
		str_len += read_len;
	}
	printf("Message from server: %s \n", message);
	printf("function call count: %d \n", str_len);
	close(sock);
	return 0;
}
```

---

## 4. 绑定IP和端口号

### （1）sockaddr_in

```c
struct sockaddr_in{
    sa_family_t		sin_family;	//地址族IPv4/IPv6
    struct in_addr	sin_addr;	//32位IP地址
    uint16_t	    sin_port;	//16位端口号
    char	sin_zero[8];	//为了和sockaddr保持一致所设置的成员，必须全填充0
}
```

sin_addr是结构体变量，类型是`struct in_addr`。但in_addr声明为uint32_t，故直接将sin_addr当做32位整型变量即可。

**bind函数第二个参数实际需要的类型是sockaddr，因此需要将sockaddr_in类型变量强转为sockaddr类型**

```c
struct sockaddr{
    sa_family_t	sin_family;	//地址族
    char		sa_data[14];	//IP+port
}
```

sa_data中应该填充地址信息，剩余位填充0。但是直接操作十分麻烦，所以有了新的结构体sockaddr_in，通过设置和强转可生成符合要求的sockaddr类型变量。

### （2）网络字节序

CPU向**内存**中写入数据/解析内存中数据存在2种方式——小端序、大端序

> 如：0x1234，高字节是12，低字节是34。大端序存储于内存中时，在从低到高字节内存中分别存储的是12、34；在小端序中存储时为34、12

#### 小端序

内存中从低字节到高字节，依次存储数据的低字节到高字节

#### 大端序

内存中从低字节到高字节，依次存储数据的高字节到低字节

#### 将网络字节序统一为大端序

主机**发送数据**和**接收数据**，都是从内存中的低字节向高字节

> 大端序主机发送0x1234时，先发送12后发送34。小端序主机接收后，将12放到低字节内存，34放到高字节内存。但是，小端序主机，将12解析为数据中的低字节，34解析为数据中的高字节，所以解析出的数据最终会变为0x3412。

### （3）字节序转换函数

h——主机字节序，n——网络字节序，l表示4字节long，s表示2字节short

#### 头文件

```c
#include<arpa/inet.h>	//头文件
```

#### htonl——将4字节无符长整形数据从主机字节序转换为网络字节序

#### htons——2字节无符短整型

#### ntohl——将4字节数据从网络字节序转化为主机字节序

#### ntohs

* 理论上，大端序的主机不需要经过转换，但实际中Intel和AMD的CPU都是小端序，故都需要经过主机字节序到网络字节序的转换。

### （4）字符串型点分十进制IP地址和整型数据互转——用较新的pton和ntop

点分十进制IP是字符串形式，需要函数将字符串形式的IP转换为32位整型数据才能绑定地址

#### 头文件

```c
#include<arpa/inet.h>	//头文件
```

#### inet_pton——文本IP转为二进制网络字节序IP

https://blog.csdn.net/zyy617532750/article/details/58595700

**IPv4、IPv6都适用**

```C
int inet_pton(int af_family, const char *str, void *addr);	//成功返回1，出错返回-1，af不是有效表达式返回0
```

> * family——AF_INET、AF_INET6（IPv6）



#### inet_ntop——二进制数值IP转成字符IP

```c
const char* inet_ntop(int af_family， const void* addr, char* str, size_t len_str)	//成功返回str，失败返回NULL
```

> * addr——二进制数值IP
> * str存储字符IP
> * len_str=sizeof(str)

```c
inet_pton(AF_INET, argc[1], &clnt_addr.sin_addr);	

char  str[INET_ADDRSTRLEN];
char* ptr_str = inet_ntop(AF_INET, &clnt_addr.sin_addr, str, sizeof(str));

```

####  inet_aton——将点分十进制字符串IP转成二进制存储在struct in_addr结构中

```c
int inet_aton(const char* str, struct in_addr* addr);	//成功返回true，失败返回false
```

> * 功能同inet_addr。该函数使用频率更高。
> * addr是sockaddr_in结构体中的成员，保存IP地址。该函数可自动将转换后的IP地址赋值给addr，所以需要该变量的地址。省去了手动给sockaddr_in变量赋值的过程。

```c
#include<arpa/inet.h>
int main(int argc, char** argv){
    sockaddr_in clnt_addr;
    
    clnt_addr.sin_family=PF_INET;
    clnt_addr.sin_port=htons(atoi(argv[2]));
    if(!inet_aton(argv[1], &clnt_addr.sin_addr)){
        error_handling("aton error..");
    }
}
```

#### inet_ntoa——将 二进制数值转成点分十进制字符串IP

```c
char* inet_ntoa(struct in_addr addr);	//成功返回字符串的地址，失败返回-1
```

> * 将32位整型IP转化为字符串点分十进制形式

#### inet_addr

```c
in_addr_t inet_addr(const char* str);	//成功时返回整型网络字节序IP，失败返回INADDR_NONE
```

> * 将字符串形式的点分十进制IP，转换成32位整型形式，且同时转换成网络字节序
> * 具有自动检测str是否是合法IP地址的功能
> * 只能转IPv4



#### atoi——字符串转整型

https://blog.csdn.net/p312011150/article/details/81273888

**头文件——<stdlib.h>**

```C
int atoi(const char* str);	//成功时返回整型，失败返回0
```

```C
//C实现：
#include <ctype.h>
#include <stdio.h>
int atoi (char s[]);
int main(void )
{
char s[100];
gets(s);
printf("integer=%d\n",atoi(s));
return 0;
}
int atoi (char s[])
{
int i,n,sign;
for(i=0;isspace(s[i]);i++)//跳过空白符;
sign=(s[i]=='-')?-1:1;	//sign标记正负号
if(s[i]=='+'||s[i]==' -')//跳过符号
  i++;
for(n=0;isdigit(s[i]);i++)
       n=10*n+(s[i]-'0');//将数字字符转换成整形数字
return sign *n;
}

```

```c
1    #include <iostream>
2    using namespace std;
3  
4    int str2int(const char *str)
5    {
6        int temp = 0;
7        const char *ptr = str;  //ptr保存str字符串开头
8  
9        if (*str == '-' || *str == '+')  //如果第一个字符是正负号，
10       {                      //则移到下一个字符
11           str++;
12       }
13       while(*str != 0)
14       {
15           if ((*str < '0') || (*str > '9'))  //如果当前字符不是数字
16           {                       //则退出循环
17               break;
18           }
19           temp = temp * 10 + (*str - '0'); //如果当前字符是数字则计算数值。数值增加一个低位，则原temp增大10倍并加上低位值
20           str++;      //移到下一个字符
21       }  
22       if (*ptr == '-')     //如果字符串是以“-”开头，则转换成其相反数
23       {
24           temp = -temp;
25       }
26 
27       return temp;
28   }
29 
30   int main()
31   {
32       int n = 0;  
33       char p[10] = "";
34 
35       cin.getline(p, 20);   //从终端获取一个字符串
36       n = str2int(p);      //把字符串转换成整型数
37      
38       cout << n << endl;
39 
40       return 0;
41   }
```



#### itoa——整型转字符串

```C
char* itoa (int value, char* str, int base );	//成功时返回指向str的指针，无错误返回
```

> value——待转整型数
>
> str——存储转换后的字符数组
>
> base——转换后的进制
>
> ```C
> //十进制转二进制
> #include<cstdlib>
> #include<cstdio>
> int main()
> {
> 	int num = 10;
> 	char str[100];
> 	int n = atoi(itoa(num, str, 2));	//先把num转换为二进制的字符串，再把该字符串转换为整数
> 	printf("%d\n",n);
> 	return 0;
> }
> ```
>
> 

### （5）绑定IP和端口

```c
#include<arpa/inet.h>
struct sockaddr_in addr;
memset(&addr, 0, sizeof(addr));	//全部置零，为了将addr中sin_zero置零
char* ip="192.168.1.5";
char* port="40000";

addr.sin_family=AF_INET;
addr.sin_addr.s_addr=inet_addr(ip);	//或是inet_aton(ip, &addr.sin_addr);
addr.sin_port=htons(atoi(port));	//atoi将字符串转成整型
```

---

## 5. TCP数据无边界导致的read和write问题

由于TCP传输数据无边界，即write的数据长度若不够一个报文段，则会等若干次write的数据后一起发送。若write的数据长度超出一个报文段，则会将数据分割为若干报文段，多次发送。但接收到数据的一端（client或server），若直接read则会导致每次read的数据都是片段。

所以应该在传输时，用变量记下write的数据的字节数。用while+read按照字节读取数据，read返回值为每次读取的字节数，待读取字节总数时，再将存储下的完整字节数据进行处理。





