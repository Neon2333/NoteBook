# 网络基础

## 1. 网络层——建立主机到主机的通信

IP数据报以**比特流bit**形式在物理连接上传输

### （1）IP地址格式

* IP=net-id+host-id，给出了**网络部分**，给出计算机所处的子网；**主机部分**计算机的主机地址。

  IPv4——32bit

  IPv6——128bit

* 划分子网

  子网掩码——那我怎么知道网络部分和主机部分分别占几位呢？解决方案是引入**子网掩码**，他也是32位二进制数，并规定网络部分全为1，主机部分全为0。子网掩码实质是确定IP地址中网络号net-id和主机号host-id的位数

  有了子网掩码，就知道了哪些是网络部分，进而**只需要把两个IP地址网络部分的网络部分对比，就知道是否在同一个子网中**

  划分子网的分片IP数据报`路由转发机制`——从分片IP数据报的首部获取目的地址，与当前路由所在网段的子网掩码AND，若与当前网段号相同，则转发到当前子网中的主机；若不同，则从当前路由的路由表依次将目的地址与子网掩码AND，若得到相同的网段则转发到相应的网关（路由）；否则，转发到默认路由或转发分组出错。

* 网段：主机号少2个，host-id全1表示广播地址（代表所有主机），全0表示网络号

### （2）IP首部校验和

[IP首部校验和计算方法](https://blog.csdn.net/clangke/article/details/6216610?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control)

[校验和计算时最高位产生进位时不能舍去，需要拆分后，将高位加到低位上](https://blog.csdn.net/yiluyangguang1234/article/details/78026020)

[IP首部校验算法](https://www.cnblogs.com/fhefh/archive/2011/10/18/2216885.html)

* 计算：

> 将某个分片IP数据报的校验字段清零
>
> 对首部的20个字节，每2字节进行反码求和（求和后取反），若相加后最高位有进位，那么不能舍弃，一定要加到低位，才能是结果正确。如0x0319BB 拆分成0X03+0X19BB

* 校验：

> 将接收到的校验和同每2字节进行反码求和，若结果为FF FF则表明IP数据包无错误，否则将该IP数据包片丢弃

```C#
对如下十六进制数据求反码校验和：

0x45c0,0x0044,0x0009,0x0000,0x0159,0x0000（归零的校验和）,0x5900,0x0009,0xe000,0x0005

对以上数据直接相加得结果：0x180bd 

按照2中规则，对此数据的处理应该是将16位数最高位的进位0x01与0x80bd相加，即得到中间结果：0x80be

按照3中规则对其取反即得校验和：0x7f41
```

### （3）IP数据报格式IP datagram

* 报头最少20字节。**总长46B~1500B**。

* 标识16bit

  由同一数据报分片得到的`分片数据报`的标识

* 标志3bit

  ```C#
  未使用1bit、DF不分片1bit、MF片未完1bit
  ```

* 片偏移13bit

  标明`分片数据区`在原数据报的`数据区`的位置。字节/8。

* 分片重组机制

  分片——将原数据报分片后加入新的报头（报头是原数据报报头的复制），通过网络的不同路径传输到目标主机。提高了效率，当出现错误时的代价较小。

  重组——通过`标识`判断是否属于同一数据报；通过`标志`的`MF`判断是否是最后一片；根据`偏移量`确定在数据报中的位置。

### （4）路由转发分片IP数据报

**通过查找路由表，判断是否在当前局域网以及不在局域网时的转发路由是什么。关键是，路由可以同时处在两个不同的局域网中。**

* 若目的主机和当前路由在同一个局域网中（网络号相同），则直接通过本路由的某个接口交付。
* 若目的主机和当前路由不在同一个局域网，但是有和目的主机在同一局域网的路由器在当前局域网。则当前路由器通过路由表查找到转发路由，将数据报转发到转发路由。由转发路由再在目标网络中转发数据报。

### （5）ARP地址解析协议

* IP	<-------->	MAC

* ARP缓存
* **在缓存中未找到对应MAC时：**

### （6）ICMP协议报文

* 两类：ICMP错误报告报文、ICMP查询报文

* ICMP错误报告报文格式：从错误分片IP数据报取出报头，首位各加8字节作为数据区，再加上ICMP错误报告报头。

* ICMP查询报文：

  PING指令调用网络层命令，发送请求与回复报文

  ARP地址解析时，从ARP缓存中没有查找到相应MAC时，在集线器上广播自身IP和MAC以及查找的IP时，对应IP回复时的报文

## 2. 传输层——建立端口到端口的通信

### （1）UDP

* 无连接（无逻辑连接），所以可以一对多，多对多，可承担广播、多播
* 不可靠（尽最大可能交付，接收端不返回确认报文）、
* 半双工（发送端和接收端交替发送）
* **面向数据报，应用层数据加上8B报头就直接送往发送缓存**
* 简单快速、耗费资源少。
* **适用于对丢包不敏感的领域：视频、直播、物联网等**

* UDP报文段格式

  伪首部12字节，首部8字节（2字节源地址、2字节目的地址、2字节包长度、2字节校验和checksum）

* 校验和

  同IP校验和只计算分片IP数据报报头不同，计算UDP报文段整个部分（伪首部、首部、数据区）

* 应用层传下来的数据到`发送缓存`，传输层从发送缓存取出数据，以UDP协议传输

* socket=IP：port

  IP只指定主机，port指定进程。socket实质是进程间通信

  UDPsocket只有目的地址+目的端口

### （2）TCP

* TCP socket需要源地址+源端口、目的地址+目的端口

* 有连接，一对一

* 全双工

* 面向字节，以字节为单位传输

* 可靠传输

  等待确认——序号seq、确认号ack（确认应答超时、确认应答丢失、）、连续ARQ协议（连续发送、累积确认）

  > ARQ协议：停止等待*ARQ*协议、回退ARQ和连续*ARQ*协议
  >
  > https://blog.csdn.net/jmq_0000/article/details/7299910

  超时重传——超时时间确定公式

  流量控制——滑动窗口rwnd，**发送端**以3个指针维护四个区域，发送缓冲区。

  > 在确认应答策略中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，这样做有一个比较大的缺点，就是性能比较差，尤其是数据往返的时间长的时候。
  >
  > （1）接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK来通知发送端
  >
  > （2）窗口大小字段越大，说明网络的吞吐率越高
  >
  > （3）窗口大小指的是无需等待确认应答而可以继续发送数据的最大值，即就是说不需要接收端的应答，可以一次连续的发送数据
  >
  > （4）操作系统内核为了维护滑动窗口，需要开辟发送缓冲区，来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉
  >
  > ps：发送缓冲区如果太大，就会有空间开销
  >
  > （5）接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端，发送端收到这个值后，就会减慢自己的发送速度
  >
  > （6）如果接收端发现自己的缓冲区满了，就会将窗口的大小设置为0，此时发送端将不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端
  >
  > （7）在TCP的首部中，有一个16为窗口字段，此字段就是用来存放窗口大小信息的
  >
  > 原文链接：https://blog.csdn.net/borderhz/article/details/117284318
  >
  > 

  拥塞控制——拥塞窗口cwnd，发送端取rwnd和cwnd较小者作为发送窗口大小。**快速重传、快速恢复**算法设置cwnd长度（字节）

* 连接建立与断开——三次握手、四次挥手

  https://zhuanlan.zhihu.com/p/78244069

  > #### **为什么需要三次握手？**
  >
  > TCP的连接因为是全双工的，也就是Client和Server两端，发送消息两个方向的连接都要建立成功。如果要保证双向连接都成功的话，三次通信是最少的次数了。大于三次的话，后面的次数通信就没有必要了，是在浪费资源。
  >
  > 二次的话，会怎么样，可不可以呢？答案是不可以，我们来看下，下面的场景。
  >
  > 在谈论这个之前，我们先要知道TCP是基于IP协议的，而IP协议是有路由的，IP协议不能够保证先发送的数据先到达，这当中依赖于IP协议底层的网络质量，以及Client与Server之间的路由跳数。
  >
  > Client在发送完Syn消息1，这里称作Syn1之后，假设因为网络原因，Syn1并没有到达Server端，这个时候Client端已经超时，Client之后重新发起SYN消息，这里称作Syn2。结果由于网络原因Syn2先到答Server，Server于是与Client基于Syn2建立了连接，结果没过多久Syn1又到达了Server,Server于是关掉了Syn2建立的那条连接，又重新建立了一条连接。对于Client来说新建立的这条连接是早就过时的，所以Client不会在这条连接上发送任何数据，这就导致了Server端长时间收不到数据，Client新的连接被断掉了。
  >
  > #### **三次握手失败了会怎么样？**
  >
  > 这里要看是在那个阶段失败的，Client在发送SYN之后没有收到ACK消息，Client会进行重传，第一次重传时间5.5-6s之间，第二次重传会是24s，不成功还会继续尝试，伯克利系统在超过75s之后，如果还是不成功，会放弃尝试连接。（备注：这里面的重传时间设置，与底层的定时器设置有过关系，可以参考TCP/IP详解卷1，这里不做详谈。）
  >
  > 如果Server没有收到最后的一次Ack消息，同样的原理，Server也会进行重传第二步的Syn+Ack消息。

* TCP报文段TCP segment 格式

  20字节首部

## 3. 总结

[总结](https://blog.csdn.net/liuchengzimozigreat/article/details/100169829)

