# 网络基础

## 1. 网络层——建立主机host到主机的通信

IP数据报以**比特流bit**形式在物理连接上传输

### （1）IP地址格式

* IP=net-id+host-id，给出了**网络部分**，给出计算机所处的子网；**主机部分**计算机的主机地址。

  IPv4——32bit

  IPv6——128bit

* 划分子网

  子网掩码——那我怎么知道网络部分和主机部分分别占几位呢？解决方案是引入**子网掩码**，他也是32位二进制数，并规定网络部分全为1，主机部分全为0。子网掩码实质是确定IP地址中网络号net-id和主机号host-id的位数

  有了子网掩码，就知道了哪些是网络部分，进而**只需要把两个IP地址网络部分的网络部分对比，就知道是否在同一个子网中**

  划分子网的分片IP数据报`路由转发机制`——从分片IP数据报的首部获取目的地址，与当前路由所在网段的子网掩码AND，若与当前网段号相同，则转发到当前子网中的主机；若不同，则从当前路由的路由表依次将目的地址与子网掩码AND，若得到相同的网段则转发到相应的网关（路由）；否则，转发到默认路由或转发分组出错。

* 网段：主机号少2个，host-id全1表示广播地址（代表所有主机），全0表示网络号

### （2）IP首部校验和

[IP首部校验和计算方法](https://blog.csdn.net/clangke/article/details/6216610?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control)

[校验和计算时最高位产生进位时不能舍去，需要拆分后，将高位加到低位上](https://blog.csdn.net/yiluyangguang1234/article/details/78026020)

[IP首部校验算法](https://www.cnblogs.com/fhefh/archive/2011/10/18/2216885.html)

* 计算：

> 将某个分片IP数据报的校验字段清零
>
> 对首部的20个字节，每2字节进行反码求和（求和后取反），若相加后最高位有进位，那么不能舍弃，一定要加到低位，才能是结果正确。如0x0319BB 拆分成0X03+0X19BB

* 校验：

> 将接收到的校验和同每2字节进行反码求和，若结果为**FFFF**则表明IP数据包无错误，否则将该IP数据包片丢弃

```C#
对如下十六进制数据求反码校验和：

0x45c0,0x0044,0x0009,0x0000,0x0159,0x0000（归零的校验和）,0x5900,0x0009,0xe000,0x0005

对以上数据直接相加得结果：0x180bd 

按照2中规则，对此数据的处理应该是将16位数最高位的进位0x01与0x80bd相加，即得到中间结果：0x80be

按照3中规则对其取反即得校验和：0x7f41
```

### （3）IPv4数据报（datagram）格式

* 报头最少20字节。**总长46B~1500B**。

* 标识16bit

  由同一数据报分片得到的`分片数据报`的标识

* 标志3bit

  ```C#
  未使用1bit、DF不分片1bit、MF片未完1bit
  ```

* 片偏移13bit

  标明`分片数据区`在原数据报的`数据区`的位置。字节/8。

* TTL（生存时间）

  一旦经过一个处理它的路由器，它的值就减1。当该字段为0时，数据报就丢弃，并发送ICMP报文通知源主机，因此可以防止进入一个循环回路时，数据报无休止地传输下去。

* 上层协议

  8bit，标明传输层处理该IP数据报应使用的协议（UDP/TCP）。

* 分片重组机制

  [分片](https://blog.csdn.net/qq_22238021/article/details/80476498)——把一个数据报为了适合网络传输而分成多个数据报的过程称为分片，被分片后的各个IP数据报可能经过不同的路径到达目标主机。

  一个IP数据报在传输过程中可能被分片，也可能不被分片。如果被分片，分片后的IP数据报和原来没有分片的IP数据报结构是相同的，即也是由IP头部和IP数据区两个部分组成。
  
  分片后的IP数据报，**数据区是原IP数据报数据区的一个连续部分**，头部是原IP数据报头部的复制，但与原来未分片的IP数据报头部有两点主要不同：标志和片偏移。
  
  将原数据报分片后加入新的报头（报头是原数据报报头的复制），通过网络的不同路径传输到目标主机。提高了效率，当出现错误时的代价较小。
  
  重组——通过`标识`判断是否属于同一数据报；通过`标志`的`MF`判断是否是最后一片；根据`偏移量`确定在数据报中的位置。

### （4）路由转发分片IP数据报

**通过查找路由表，判断是否在当前局域网以及不在局域网时的转发路由是什么（默认路由）。关键是，路由可以同时处在两个不同的局域网中。**

* 若目的主机和当前路由在同一个局域网中（网络号相同），则直接通过本路由的某个接口交付。
* 若目的主机和当前路由不在同一个局域网，但是有和目的主机在同一局域网的路由器在当前局域网。则当前路由器通过路由表查找到转发路由，将数据报转发到转发路由。由转发路由再在目标网络中转发数据报。

### （5）ARP地址解析协议

* IP	<-------->	MAC

* ARP缓存
* **在缓存中未找到对应MAC时：将自身MAC地址作为源MAC地址，将目的MAC地址设为FF FF FF FF FF FF，封装成MAC帧，在集线器上广播，目标主机收到后返回ICMP报文**

### （6）ICMP协议报文

* 两类：ICMP错误报告报文、ICMP查询报文

* ICMP错误报告报文格式：从错误分片IP数据报取出报头，首位各加8字节作为数据区，再加上ICMP错误报告报头。

* ICMP查询报文：

  PING指令调用网络层命令，发送请求与回复报文

  ARP地址解析时，从ARP缓存中没有查找到相应MAC时，在集线器上广播自身IP和MAC以及查找的IP时，对应IP回复时的报文

## 2. 传输层——建立进程(端口)到进程的通信

在IP地址的基础上添加**端口**再加以封装

### 1. UDP

* 无连接（无逻辑连接），所以可以一对多，多对多，可承担广播、多播

* 不可靠（尽最大可能交付，接收端不返回确认报文）、

* 半双工（发送端和接收端交替发送）

* **面向数据报，应用层数据加上8B报头就直接送往发送缓存**

* 简单快速、耗费资源少。

* **适用于对丢包不敏感的领域：视频、直播、物联网等**

* UDP报文段格式

  伪首部12字节，首部8字节（2字节源端口、2字节目的端口、2字节UDP报文长度、2字节校验和checksum）

  > 1）源端口（2 字节）：发送方端口号
  >
  > 2）目的端口（2 字节 ）：接收方端口号
  >
  > 3）报文长度（2 字节）：UDP 用户数据报的总长度，以字节为单位。
  >
  > 4）校验和（2 字节）：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。
  >
  > 5)   数据区：UDP 的数据部分如果不为偶数需要用 0 填补，就是说，如果数据长度为奇数，数据长度加“1”。

* 校验和

  同IP校验和只计算分片IP数据报报头不同，计算UDP报文段整个部分（伪首部、首部、数据区）

* 应用层传下来的数据到`发送缓存`，传输层从发送缓存取出数据，以UDP协议传输

* **socket=IP：port**

  **端口号长度为2个字节，有效范围是0到65536。**

  IP只指定主机，port指定进程。socket实质是进程间通信
  
  UDPsocket只有目的地址+目的端口

### 2. TCP

* TCP报文段（segment ）格式

  最少20字节的首部

  > 1)	源端口（16位）
  >
  > 2）目的端口（16位）
  >
  > 3） 序号seq（也叫序列号）（32位）
  >
  > 4）确认号ack（32位）
  >
  > 5） 数据偏移（首部长度）（4位）
  >
  > 6）保留位（6位）
  >
  > 7）控制位（6位）
  >
  > > SYN标志位——新建连接。仅在三次握手建立 TCP 连接时有效。
  > >
  > > FIN——释放连接
  > >
  > > ACK——确认标志
  >
  > 8）窗口（16位）
  >
  > 指发送本报文段的一方的接收窗口（而不是自己的发送窗口）。
  >
  > 此字段用来进行流量控制，**这个值是本机期望一次接收的字节数（告知发送方下次期望发送的数据的长度）**，即发送数据的窗口大小。告诉对方在不等待确认的情况下，可以发来多大的数据。这里表示的最大长度是2^16 - 1 = 65535，如需要使用更大的窗口大小，需要使用选项中的窗口扩大因子选项。
  >
  >  9）校验和（16位）
  >
  > 源主机和目的主机计算TCP报文段整个部分（伪首部、首部、数据区）计算校验和。
  >
  > 10）紧急指针（16位）
  >
  > 11）选项、填充字段
  >
  > 12）数据区（长度可变）
  >
  > 数据区MSS（最大报文段长度，不包括段头）：1460B（IP数据报最大长度1500B-IP数据报报头20B-TCP报文段段头最小20B）

* TCP socket需要源地址+源端口、目的地址+目的端口

* 有连接，一对一

* 全双工

* 面向字节，以字节为单位传输

* 可靠传输

  等待确认——序号seq（**随机产生一个值seq**（[这样可避免黑客很容易猜到序列号而发起攻击](https://blog.csdn.net/qq_40910541/article/details/88760627)）、确认号ack（确认应答超时、确认应答丢失、）、连续ARQ协议（连续发送、累积确认）

  > ARQ协议：停止等待*ARQ*协议、回退ARQ和连续*ARQ*协议
  >
  > https://blog.csdn.net/jmq_0000/article/details/7299910

  超时重传——超时时间确定公式

  流量控制——滑动窗口rwnd，**发送端**以3个指针维护四个区域，发送缓冲区。

  > 在确认应答策略中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，这样做有一个比较大的缺点，就是性能比较差，尤其是数据往返的时间长的时候。
  >
  > （1）接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK来通知发送端
  >
  > （2）窗口大小字段越大，说明网络的吞吐率越高
  >
  > （3）窗口大小指的是无需等待确认应答而可以继续发送数据的最大值，即就是说不需要接收端的应答，可以一次连续的发送数据
  >
  > （4）操作系统内核为了维护滑动窗口，需要开辟发送缓冲区，来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉
  >
  > ps：发送缓冲区如果太大，就会有空间开销
  >
  > （5）接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端，发送端收到这个值后，就会减慢自己的发送速度
  >
  > （6）如果接收端发现自己的缓冲区满了，就会将窗口的大小设置为0，此时发送端将不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端
  >
  > （7）在TCP的首部中，有一个16为窗口字段，此字段就是用来存放窗口大小信息的
  >
  > 原文链接：https://blog.csdn.net/borderhz/article/details/117284318
  >
  > 

  拥塞控制——拥塞窗口cwnd，发送端取rwnd和cwnd较小者作为发送窗口大小。**快速重传、快速恢复**算法设置cwnd长度（字节）

* 连接建立与断开——三次握手、四次挥手

  https://zhuanlan.zhihu.com/p/78244069

  > #### **为什么需要三次握手？**
  >
  > TCP的连接因为是全双工的，也就是Client和Server两端，发送消息两个方向的连接都要建立成功。如果要保证双向连接都成功的话，三次通信是最少的次数了。大于三次的话，后面的次数通信就没有必要了，是在浪费资源。
  >
  > 二次的话，会怎么样，可不可以呢？答案是不可以，我们来看下，下面的场景。
  >
  > 在谈论这个之前，我们先要知道TCP是基于IP协议的，而IP协议是有路由的，IP协议不能够保证先发送的数据先到达，这当中依赖于IP协议底层的网络质量，以及Client与Server之间的路由跳数。
  >
  > Client在发送完Syn消息1，这里称作Syn1之后，假设因为网络原因，Syn1并没有到达Server端，这个时候Client端已经超时，Client之后重新发起SYN消息，这里称作Syn2。结果由于网络原因Syn2先到答Server，Server于是与Client基于Syn2建立了连接，结果没过多久Syn1又到达了Server,Server于是关掉了Syn2建立的那条连接，又重新建立了一条连接。对于Client来说新建立的这条连接是早就过时的，所以Client不会在这条连接上发送任何数据，这就导致了Server端长时间收不到数据，Client新的连接被断掉了。
  >
  > #### **三次握手失败了会怎么样？**
  >
  > 这里要看是在那个阶段失败的，Client在发送SYN之后没有收到ACK消息，Client会进行重传，第一次重传时间5.5-6s之间，第二次重传会是24s，不成功还会继续尝试，伯克利系统在超过75s之后，如果还是不成功，会放弃尝试连接。（备注：这里面的重传时间设置，与底层的定时器设置有过关系，可以参考TCP/IP详解卷1，这里不做详谈。）
  >
  > 如果Server没有收到最后的一次Ack消息，同样的原理，Server也会进行重传第二步的Syn+Ack消息。
  >
  > 四次挥手：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃
  >
  > [MSL、TTL和RTT简介](https://www.cnblogs.com/zhangkele/p/10323588.html)

* ###### 关于 TIME_WAIT 状态的说明

  客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？

  TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器A每次向机器B发送数据包后，都要求机器B”确认“，回传ACK包，告诉机器A我收到了，这样机器A才能知道数据传送成功了。如果机器B没有回传ACK包，机器A会重新发送，直到机器B回传ACK包。

  客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。那么，要等待多久呢？

  **数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为报文最大生存时间（MSL，Maximum Segment Lifetime）。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包。**


## 3. 数据链路层

### 1. MAC帧格式

* 帧头16B：源MAC地址6B，目的MAC地址6B
* 



## 4. 总结

[总结](https://blog.csdn.net/liuchengzimozigreat/article/details/100169829)

### 1. [路由器工作原理](https://blog.csdn.net/hhthwx/article/details/78617877)

### 2. [MAC表、ARP表、路由表1](https://blog.csdn.net/bzhxuexi/article/details/44237633)

[路由表、ARP表、MAC表2](https://zhuanlan.zhihu.com/p/139355604)

> 路由表——网络层，选择最短路径，判断下一跳网关是哪个。（用来在**局域网间**寻找下一跳要传送到的局域网的网关）
>
> ARP表——数据链路层，IP→MAC（得到下一跳网关的MAC），将目的MAC地址封装进MAC数据帧。（**局域网内部**起作用，获取目标主机的MAC地址）
>
> MAC表——用于交换机，MAC地址→接口，用于交换机确定目的MAC对应的主机要通过那个接口发送（接口与MAC绑定），实现单播，由交换机负责将数据包发送到某一个设备，而不是将数据包在局域网内广播到所有设备。这样连接在同一个交换机上的设备之间是无法截取发送给另一个设备的数据包的。

### 3. [详解一次完整的数据包传输过程 -- 层层递进](https://blog.csdn.net/u011563903/article/details/90116368)

> 传输层封装源端口、目的端口
>
> 网络层封装源IP、目的IP
>
> 数据链路层封装源MAC、目的MAC
>
> 层层封装与解封的过程类似于将信件（数据）放入层层信封，信件就是从应用层传下来的数据区，每一层拆开信封后拿出内容都重填“寄件人”（源MAC地址）和“收件人”（目的MAC地址）。某一层的设备只解封到相应层，不会 拆开上一层对应的“内部”的信封，拆开后从信封封面读取该层所需信息。重新封装也是拿一个新的当前层对应的信封，将手里当前的信封装入，并在信封上写上新的发件人、收件人等信息。

### 4.[路由器和交换机的区别](https://blog.csdn.net/baidu_32045201/article/details/78305586)

> 集线器工作在第一层物理层，路由器工作在第三层网络层，交换机工作在第二层数据链路层
>
> 路由器和交换机的主要工作如下：
> **路由器：寻址，转发（依靠 IP 地址）**
> **交换机：过滤，转发（依靠 MAC 地址）**
>
> **每一个路由器与其之下连接的设备，其实构成一个局域网**
> 交换机工作在路由器之下，就是也就是**交换机工作在局域网内**
> 交换机用于**局域网内网的数据转发**
> 路由器用于**连接局域网和外网**
>
> 路由器发送数据——广播
>
> 交换机——单播：一个接口接一个host，若MAC表中有目的MAC对应的交换机接口则直接通过相应接口单播转发到目的host；若MAC表中没有目的MAC对应的接口，则通过所有**非接收接口**进行广播，目的主机接收后返回响应，交换机会将目的主机和接口的对应关系记录到MAC表中，下次发送时就直接向对应接口发送实现单播。

### 5. 各层封装

TCP segment——应用层数据+端口号

IP datagram——TCP segment+IP地址

MAC frame——IP datagram+MAC地址

# Socket初步

Socket技术即利用了计算机网络的原理，封装了五层网络模型，提供了一系列API（函数），来实现以上协议，使得客户端和服务器主机上的进程之间可以互相通信。

[Socket技术详解](https://www.jianshu.com/p/066d99da7cbd)

