# Part 00——注意点收集



## 1. vs code编译报错`__imp_WASartup`等的解决办法

![image-20210827231215022](https://i.loli.net/2021/08/27/mElYtpyM84CV2eU.png)

https://blog.csdn.net/qq_20916555/article/details/50938424

https://www.yht7.com/news/127552

## 2. 127.0.0.1——回送地址

127.0.0.1是回送地址（loopback address），替代当前计算机的IP。

---

# Part 01——C# Socket



## 1. DNS解析

### 头文件——System.Net

### （1）主机类——IPHostEntry

* 服务器主机信息的容器，将服务器的URI、IP地址列表（一个URI可能对应好几台服务器，因此也就有好几个IP）、一组别名相关联并封装。

```c#
IPHostEntry hostInfo = Dns.GetHostEntry("www.bing.com");	//将uri "www.bing.com"经过DNS解析，返回存储着主机信息的	//IPHostEntry实例
```

#### 属性

> * AddressList——获取/设置主机的IP地址列表
>
>   ```C#
>   public IPAddress[] AddressList	{get; set;}
>   ```
>  
>     ```c#
>   // Get 'IPHostEntry' object containing information like host name, IP addresses, aliases for a host.
>           IPHostEntry hostInfo = Dns.GetHostByName(hostString);
>           Console.WriteLine("Host name : " + hostInfo.HostName);
>           Console.WriteLine("IP address List : ");
>           for(int index=0; index < hostInfo.AddressList.Length; index++)
>           {
>               Console.WriteLine(hostInfo.AddressList[index]);
>           }
>     ```
>   
> * HostName——获取主机的DNS名称/URI
>
>   ```C#
>  public string HostName { get; set; }
>   ```
> 
> * Aliases——获取主机别名
>
>   ```c#
>    public string[] Aliases { get; set; }
>   ```

### （2）IP地址类——IPAddress

获取服务器的IP地址相关信息。

Tostring()转化为点分十进制形式的IP。

#### 属性

> * Address——十进制形式IP（已过时）
> * AddressFamily——IP地址使用的地址族

### （3）Dns类

该类提供简单的DNS解析功能。

#### 方法

> * GetHostEntry(string)——将**主机名或 IP 地址**解析为IPHostEntry实例。（Resolve已过时）
>
> * GetHostName()——获取本地计算机主机名
>
> * GetHostAddresses(string)——返回指定主机的 Internet 协议 (IP) 地址
>
>   ```c#
>   public static System.Net.IPAddress[] GetHostAddresses (string hostNameOrAddress);
>   ```
>
> * BeginGetHostEntry(String, AsyncCallback, Object)——将主机名或 IP 地址**异步**解析为IPHostEntry实例
>
>   ```C#
>   public static IAsyncResult BeginGetHostEntry (string hostNameOrAddress, AsyncCallback? requestCallback, object? stateObject);
>   ```



## 2. HTTP

### （1）WebClient



### （2）WebRequest



### （3）WebResponse



### （4）浏览器控件

添加WebBrowser控件

![image-20210913223432788](https://i.loli.net/2021/09/13/5X7Ioh4H9jmTbzP.png)

```c#
 private void button1_Click(object sender, EventArgs e)
 {
 	webBrowser1.Navigate(textBox_searchUri.Text, false);
 }
```



## 3. TCP



---

# Part 02——C/C++ Socket

[Socket技术详解](https://www.jianshu.com/p/066d99da7cbd)

## 1. 文件IO和ANSI标准IO

https://blog.csdn.net/owen7500/article/details/53263981

文件IO——OS提供的底层IO，没有缓冲

标准IO——封装了缓冲机制，调用OS底层IO的IO

---

## 2. server--->client的基本流程

### Linux

#### （1）server

> ##### 创建套接字——socket
>
> ```c
> //Linux
> #include<stdlib.h>
> #include<stdio.h>
> #include<sys/socket.h>
> int socket(int domain, int type, int protocol);	//成功返回文件描述符fd，失败返回-1
> ```
>
> ```c
> int fd = socket(PF_INET, SOCK_DGRAM, 0);
> ```
>
> ##### 套接字绑定地址——bind
>
> ```c
> //Linux
> #include<sys/socket.h>
> int bind(int sock, struct sockaddr* server_addr, socklen_t addrlen);	//成功返回0，失败返回-1
> ```
>
> ```c
> struct sockaddr_in serv_addr;	//定义server地址为sockaddr_in类型
> memset(&serv_addr,0,sizeof(serv_addr));	//置0
> serv_addr.sin_family=AF_INET;	//IPv4
> serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);	//绑定IP地址，INADDR_ANY表示所有网卡的IP
> serv_addr.sin_port=htons(atoi(argv[1]));	//命令行第2个参数为server监听的端口
> if(bind(sock,(struct sockaddr*)&serv_addr, sizeof(serv_addr))==-1){
>  serv_bindHandling();
> }
> ```
>
> * **INADDR_ANY**
>
> > NADDR_ANY
> > 转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。
> > 比如一台电脑有3块网卡，分别连接三个网络，那么这台电脑就有3个ip地址了，如果某个应用程序需要监听某个端口，那他要监听哪个网卡地址的端口呢？
> >
> > 如果绑定某个具体的ip地址，你只能监听你所设置的ip地址所在的网卡的端口，其它两块网卡无法监听端口，如果我需要三个网卡都监听，那就需要绑定3个ip，也就等于需要管理3个套接字进行数据交换，这样岂不是很繁琐？
> >
> > 所以出现INADDR_ANY，你只需绑定INADDR_ANY，管理一个套接字就行，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
>
> * **htonl——将主机的32位无符号长整形数转换成网络字节顺序**
>
> ```c
> uint32_t htonl(uint32_t hostlong);
> ```
>
> * **htons——将主机的16位无符号短整形数转换成网络字节顺序**
>
> ```c
> uint16_t htonl(uint16_t hostshort);
> ```
>
> * **atoi——把字符串转成整型数，跳过空字符。字符不能转成int或空字符时，无法转换时返回0。**
>
> ```c
> int atoi(const char *nptr); 
> ```
>
> **网络字节序**
>
> > 所谓网络字节顺序（大尾顺序）就是指一个数在内存中存储的时候“高对低，低对高”（即一个数的高位字节存放于低地址单元，低位字节存放在高地址单元中）。但是计算机的内存存储数据时有可能是大尾顺序或者小尾顺序。
> >
> > 先举个例子：
> > int a = 0x403214;
> > int b = htonl(a);
> > 我在VC++6.0调试这段代码，发现
> > &a的值为：0x0012ff44
> > 其中0x0012ff44、0x0012ff45、0x0012ff46、0x0012ff47这四个单元的值依次为：14、32、40、00，即0x403214这个数的高位部分存放在高位地址中，低位部分存放在低位地址中，即小尾顺序。
> > &b的值为：0x0012ff40
> > 其中0x0012ff40、0x0012ff41、0x0012ff42、0x0012ff43这四个单元的值依次为：00、40、32、14，即把原数0x403214的高位部分存放在低位地址中，低位部分存放在高位地址中。
> > 由此可见，如果一个数以小尾顺序存储，经htonl函数调用后这个数的高地位字节会完全颠倒过来成为一个新的数。这个新的数在机器内部其实还是以小尾顺序存储的，但是相对于原来的数而言相当于是变成大尾顺序的了。
> > long型的0x40写完整为:0x 00 00 00 40，共四个字节，调用htonl后四个字节颠倒顺序，为0x 40 00 00 00。
> > 同样，0x40 00 00 00调用htonl后变为0x 00 00 00 40，即0x40
>
> * 转为监听状态——Listen
>
>   ```c
>   //Linux
>   #include<sys/socket.h>
>   int listen(int sock, int backlog);	//成功返回0，失败返回-1
>   ```
>
>   > backlog——服务器接受的请求队列的长度。当有多个客户端同时请求时，服务端无法对所有进行处理，设置队列将请求放入其中，backlog设置队列长度。backlog=10，若来20个请求，则后面10个会被server拒绝不会给对应的client发送rst，这10个client将继续发送TCP SYN，带队列中有请求通过三次握手建立了TCP连接将会从队列中移到另一个队列中。空出位置才能供后续请求移入。
>
> * 阻塞接收消息——accept
>
>   ```c
>   //Linux
>   #include<sys/socket.h>
>   int accept(int sock, struct sockaddr* client_addr, socklen_t* addrlen);	//成功返回文件描述符fd，失败返回-1
>   ```
>
>   ```c
>   struct sockaddr_in serv_addr;
>   int clnt_addr_size = sizeof(clnt_addr);
>   if(accept(sock,(struct sockaddr_in*)&clnt_addr, &clnt_addr_size)==-1){
>       serv_acceptHandling();
>   }
>   ```
>
>   ```c++
>   //message_server.cpp
>                           
>   ```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(char *message);

int main(int argc, char *argv[])
{
	int serv_sock;
	int clnt_sock;

	struct sockaddr_in serv_addr;
	struct sockaddr_in clnt_addr;
	socklen_t clnt_addr_size;

	char message[]="Hello World!";
	
	if(argc!=2){
		printf("Usage : %s <port>\n", argv[0]);
		exit(1);
	}
	
	serv_sock=socket(PF_INET, SOCK_STREAM, 0);
	if(serv_sock == -1)
		error_handling("socket() error");
	
	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family=AF_INET;
	serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);
	serv_addr.sin_port=htons(atoi(argv[1]));
	
	if(bind(serv_sock, (struct sockaddr*) &serv_addr, sizeof(serv_addr))==-1 )
		error_handling("bind() error"); 
	
	if(listen(serv_sock, 5)==-1)
		error_handling("listen() error");
	
	clnt_addr_size=sizeof(clnt_addr);  
	clnt_sock=accept(serv_sock, (struct sockaddr*)&clnt_addr,&clnt_addr_size);
	if(clnt_sock==-1)
		error_handling("accept() error");  
	
	write(clnt_sock, message, sizeof(message));
	close(clnt_sock);	
	close(serv_sock);
	return 0;
}

void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```



#### （2）client

> * 创建套接字
>
> * 连接server——connect
>
>   ```c
>   //Linux
>   struct sockaddr_in serv_addr;
>   memset(&serv_addr,0,sizeof(serv_addr));
>   
>   serv_addr.sin_family=AF_INET;
>   serv_addr.sin_addr.s_addr=inet_addr(argv[1]);	//server这里是htonl(INADDR_ANY)
>   serv_addr.sin_port=htons(atoi(argv[2]));
>   
>   int connect(int sock, struct sockaddr* server_addr,socklen_t addrlen);	//成功返回0，失败返回-1
>   ```
>
> * 读写数据——IO
>
>   ```c
>   //打开文件
>   #include<sys/types.h>
>   #include<sys/stat.h>
>   #include<fcntl.h>
>   int open(const char* filePath, int flag);	//成功返回文件描述符fd，失败返回-1
>   ```
>
>   > flag——打开模式
>   >
>   > ![image-20210821220713441](https://i.loli.net/2021/08/21/Ehwz9ZHdvrbUeDa.png)
>
>   ```c
>   //关闭文件
>   //关闭文件、套接字都是该函数
>   #include<unistd.h>
>   int close(int fd)	//成功返回0，失败返回-1
>   ```
>
>   ```c
>   //写入文件
>   #include<unistd.h>
>   ssize_t write(int fd, const void* buf, size_t nbytes);	//成功返回写入的字节数，失败返回-1
>   //size_t是由typedef定义的unsigned int，ssize_t是signed int
>   ```
>
>   > fd——文件描述符
>   >
>   > buf——缓存待写入数据的内存
>   >
>   > nbytes——要写入的数据的字节数
>
>   ```c
>   int fd = open("C:\\Users\\25224\\Desktop\\test.dat",O_RDONLY|O_APPEND);
>   if(fd==-1){
>       open_handling();
>   }
>   const char buf[]="this is a open file test..";
>   if(write(fd, buf, sizeof(buf))==-1){
>       write_handling();
>   }
>   close(fd);
>   ```
>
>   ```c
>   //读取文件
>   #include<unistd.h>
>   ssize_t read(int fd, void* buf, size_t nbytes);	//成功返回读取的字节数，失败返回-1
>   ```
>
>   > fd——文件描述符
>   >
>   > buf——保存读取数据的内存
>   >
>   > nbytes——读取的最大字节数
>
>   ```c
>   #define BUF_SIZE 100;
>   int fd = open("C:\\Users\\25224\\Desktop\\test.dat",O_RDONLY);
>   if(fd==-1){
>       open_handling();
>   }
>   char buf[BUF_SIZE]={0};
>   if(read(fd, buf, sizeof(buf))==-1){
>       read_handling();
>   }
>   ```
>
>   ```c++
>   //message_client.cpp
>                   
>   ```
>
> 

### Windows

#### （1）server

```c
//Windows
#include<winsock2.h>
SOCKET socket(int af, int type, int protocol);	//失败返回INVALID_SOCKET
```

```c
//Windows
#include<winsock2.h>
int bind(SOCKET s, const struct sockaddr* name, int namelen);	//成功返回0，失败返回SOCKET_ERROR
```

```c
//Windows
int listen(SOCKET s, int backlog);	//成功返回0，失败返回SOCKET_ERROR
```

```c
//Windows
SOCKET accept(SOCKET s, struct sockaddr* server_addr, int* addrlen);	//成功返回套接字句柄，失败返回INVALID_SOCKET
```

#### （2）client

```c
//Windows
int connect(SOCKET s, const struct sockaddr* name, int namelen);	//成功返回0,，失败返回SOCKET_ERROR
```

#### （3）Windows和Linux区别

* Linux中文件和套接字都用文件描述符描述。Windows中分别用文件句柄和套接字句柄描述。

* 关闭socket

  ```c
  //Linux
  sock.close();	//同文件关闭
  //Windows
  closesocket(sock)	//socket关闭函数
  ```

* Windows使用ws2_32.lib库。定义套接字前，需要初始化库。程序结束前，需将库归还OS，之后无法调用socket函数

  ```c
  #include<winsock2.h>
  int WSAStartup(WROD versionWinsock, WSADATA* lpWSAData);	//成功时返回0
  ......
  int WSACleanup();	//成功返回0，失败返回SOCKET_ERROR
  ```

  > versionWinsock——winsock的版本号，通过MAKEWORD函数方便生成版本号，如主版本1副版本2，MAKEWORD(1, 2)生成0x0201，高位为副版本号

  ```c
  int main(int argc, int argv[]){
      WSADATA wsaData;
      if(WSAStartup(MAKEWORD(2,2),&wsaData)!=0){
          Error_handling("WSAStartup error");
      }
      return 0;
  }
  ```

* 两平台函数名、参数名都相同，只是返回值类型使用不同，需关注。

  > Linux——返回int值，保存文件描述符。错误返回-1
  >
  > ```c
  > SOCKET soc = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
  > if(soc == -1){
  >  ErrorHandling();
  > }
  > ```
  >
  > Win——返回值结构体SOCKET，保存整数型套接字句柄值（本质也是int，为了扩展性定义为SOCKET）.错误返回INVALID_SOCKET
  >
  > ```c
  > SOCKET soc = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
  > if(soc == INVALID_SOCKET){
  >  ErrorHandling();
  > }
  > ```

---

## 3. 创建套接字

### （1）socket函数

```c
//创建socket，此时尚且未分为sock_serv或sock_clnt
//经过bind、listen后的转为sock_serv，经过accecpt的转为sock_clnt
#include<sys/socket.h>
int socket(int domain, int type ,int protocol);	//失败时：-1
```

> domain——协议族
>
> > PF_INET——IPv4
> >
> > PF_INET——IPv6
>
> type——数据传输方式（某个协议族中有多种数据传输方式）
>
> > SOCK_STREAM——面向连接、可靠、有序传输、流量控制、多次发送一次读取
> >
> > SOCK_DGRAM——无连接、不可靠、高速传输、一次发送对应一次读取
>
> protocol——指定具体协议（一般置0，若某协议族中同样数据传输方式的协议有多个，则需要指定具体是哪个协议）
>
> > IPPROTO_TCP
> >
> > IPPROTO_UDP

### （2）Linux建立TCP套接字

```c
/**
*tcp_client.c
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(char* message) {
	printf("%s\n", message);
}

int main(int argc, char* argv[])
{
	int sock;
	struct sockaddr_in serv_addr;
	char message[30];
	int str_len = 0;
	int idx = 0, read_len = 0;

	if (argc != 3) {
		printf("Use: %s<IP> <port>\n", argv[0]);	//若执行程序的命令行参数不是3，则打印格式："tcp_client <IP> <port>"
		exit(l);
	}

	sock = socket(PF_ INET, SOCK_STREAM, 9);
	if (sock == -1)
		error_handling("socket() error");

	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = inet_addr(argv[1]]);	//从命令行参数中取出IP地址
	serv_add.sin_port = htons(atoi(argv[2]));	//从命令行参数中取出端口
	if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {
		error_handling("connect error");
	}
	while (read_len = read(sock, &message[idx++], 1)) {
		if (read_len == -1) {
			error_handling("read error");
		}
		str_len += read_len;
	}
	printf("Message from server: %s \n", message);
	printf("function call count: %d \n", str_len);
	close(sock);
	return 0;
}
```

---

## 4. 绑定IP和端口号

### （1）sockaddr_in

```c
struct sockaddr_in{
    sa_family_t		sin_family;	//地址族IPv4/IPv6
    struct in_addr	sin_addr;	//32位IP地址
    uint16_t	    sin_port;	//16位端口号
    char	sin_zero[8];	//为了和sockaddr保持一致所设置的成员，必须全填充0
}
```

sin_addr是结构体变量，类型是`struct in_addr`。但in_addr声明为uint32_t，故直接将sin_addr当做32位整型变量即可。

**bind函数第二个参数实际需要的类型是sockaddr，因此需要将sockaddr_in类型变量强转为sockaddr类型**

```c
struct sockaddr{
    sa_family_t	sin_family;	//地址族
    char		sa_data[14];	//IP+port
}
```

sa_data中应该填充地址信息，剩余位填充0。但是直接操作十分麻烦，所以有了新的结构体sockaddr_in，通过设置和强转可生成符合要求的sockaddr类型变量。

### （2）网络字节序

CPU向**内存**中写入数据/解析内存中数据存在2种方式——小端序、大端序

> 如：0x1234，高字节是12，低字节是34。大端序存储于内存中时，在从低到高字节内存中分别存储的是12、34；在小端序中存储时为34、12

#### 小端序

内存中从低字节到高字节，依次存储数据的低字节到高字节

#### 大端序

内存中从低字节到高字节，依次存储数据的高字节到低字节

#### 将网络字节序统一为大端序

主机**发送数据**和**接收数据**，都是从内存中的低字节向高字节

> 大端序主机发送0x1234时，先发送12后发送34。小端序主机接收后，将12放到低字节内存，34放到高字节内存。但是，小端序主机，将12解析为数据中的低字节，34解析为数据中的高字节，所以解析出的数据最终会变为0x3412。

### （3）字节序转换函数

h——主机字节序，n——网络字节序，l表示4字节long，s表示2字节short

#### 头文件

```c
#include<arpa/inet.h>	//头文件
```

#### htonl——将4字节数据从主机字节序转换为网络字节序

#### htons

#### ntonl——将4字节数据从网络字节序转化为主机字节序

#### ntons

* 理论上，大端序的主机不需要经过转换，但实际中Intel和AMD的CPU都是小端序，故都需要经过主机字节序到网络字节序的转换。

### （4）字符串型IP地址转换为32位整型数据

点分十进制IP是字符串形式，需要函数将字符串形式的IP转换为32位整型数据才能绑定地址

#### 头文件

```c
#include<arpa/inet.h>	//头文件
```

#### inet_addr

```c
in_addr_t inet_addr(const char* str);	//成功时返回整型网络字节序IP，失败返回INADDR_NONE
```

> * 将字符串形式的点分十进制IP，转换成32位整型形式，且同时转换成网络字节序
> * 具有自动检测str是否是合法IP地址的功能

####  inet_aton

```c
int inet_aton(const char* str, struct in_addr* addr);	//成功返回true，失败返回false
```

> * 功能同inet_addr。该函数使用频率更高。
> * addr是sockaddr_in结构体中的成员，保存IP地址。该函数可自动将转换后的IP地址赋值给addr，所以需要该变量的地址。省去了手动给sockaddr_in变量赋值的过程。

```c
#include<arpa/inet.h>
int main(int argc, char** argv){
    sockaddr_in clnt_addr;
    
    clnt_addr.sin_family=PF_INET;
    clnt_addr.sin_port=htons(atoi(argv[2]));
    if(!inet_aton(argv[1], &clnt_addr.sin_addr)){
        error_handling("aton error..");
    }
}
```

#### inet_ntoa

```c
char* inet_ntoa(struct in_addr addr);	//成功返回字符串的地址，失败返回-1
```

> * 将32位整型IP转化为字符串点分十进制形式

### （5）绑定IP和端口

```c
#include<arpa/inet.h>
struct sockaddr_in addr;
memset(&addr, 0, sizeof(addr));	//全部置零，为了将addr中sin_zero置零
char* ip="192.168.1.5";
char* port="40000";

addr.sin_family=AF_INET;
addr.sin_addr.s_addr=inet_addr(ip);	//或是inet_aton(ip, &addr.sin_addr);
addr.sin_port=htons(atoi(port));	//atoi将字符串转成整型
```

---

## 5. 基于TCP/UDP的server和client

