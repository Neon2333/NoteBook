# 网络基础

## 1. 网络层——建立主机host到主机的通信

IP数据报以**比特流bit**形式在物理连接上传输

### （1）IP地址格式

* IP=net-id+host-id，给出了**网络部分**，给出计算机所处的子网；**主机部分**计算机的主机地址。

  IPv4——32bit

  IPv6——128bit

* 划分子网

  子网掩码——那我怎么知道网络部分和主机部分分别占几位呢？解决方案是引入**子网掩码**，他也是32位二进制数，并规定网络部分全为1，主机部分全为0。子网掩码实质是确定IP地址中网络号net-id和主机号host-id的位数

  有了子网掩码，就知道了哪些是网络部分，进而**只需要把两个IP地址网络部分的网络部分对比，就知道是否在同一个子网中**

  划分子网的**分片IP数据报**`路由转发机制`——从分片IP数据报的首部获取目的地址，与当前路由所在网段的子网掩码AND，若与当前网段号相同，则转发到当前子网中的主机；若不同，则从当前路由的路由表依次将目的地址与子网掩码AND，若得到相同的网段则转发到相应的网关（路由）；否则，转发到默认路由或转发分组出错。

* 网段：主机号少2个，host-id全1表示广播地址（代表所有主机），全0表示网络号

### （2）IP首部校验和

[IP首部校验和计算方法](https://blog.csdn.net/clangke/article/details/6216610?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control)

[校验和计算时最高位产生进位时不能舍去，需要拆分后，将高位加到低位上](https://blog.csdn.net/yiluyangguang1234/article/details/78026020)

[IP首部校验算法](https://www.cnblogs.com/fhefh/archive/2011/10/18/2216885.html)

* 计算：

> 将某个分片IP数据报的校验字段清零
>
> 对首部的20个字节，每2字节进行反码求和（求和后取反），若相加后最高位有进位，那么不能舍弃，一定要加到低位，才能是结果正确。如0x0319BB 拆分成0X03+0X19BB

* 校验：

> 将接收到的分片IP数据包的校验字段和同每2字节进行反码求和，若结果为**FFFF**则表明IP数据包无错误，否则将该IP数据包片丢弃

```C#
对如下十六进制数据求反码校验和：

0x45c0,0x0044,0x0009,0x0000,0x0159,0x0000（归零的校验和）,0x5900,0x0009,0xe000,0x0005

对以上数据直接相加得结果：0x180bd 

按照2中规则，对此数据的处理应该是将16位数最高位的进位0x01与0x80bd相加，即得到中间结果：0x80be

按照3中规则对其取反即得校验和：0x7f41
```

### （3）IPv4数据报（datagram）格式

* 报头最少20字节。**总长46B~1500B**。

* 标识16bit

  由同一数据报分片得到的`分片数据报`的标识

* 标志3bit

  ```C#
  未使用1bit、DF不分片1bit、MF片未完1bit
  ```

* 片偏移13bit

  标明`分片数据区`在原数据报的`数据区`的位置。字节/8。

* TTL（生存时间）

  一旦经过一个处理它的路由器，它的值就减1。当该字段为0时，数据报就丢弃，并发送ICMP报文通知源主机，因此可以防止进入一个循环回路时，数据报无休止地传输下去。

* 上层协议

  8bit，标明传输层处理该IP数据报应使用的协议（UDP/TCP）。

* **分片重组机制**

  [分片](https://blog.csdn.net/qq_22238021/article/details/80476498)——把一个IP数据报为了适合网络传输而分成多个数据报的过程称为分片，被分片后的各个**分片IP数据报**可能经过不同的路径到达目标主机。

  一个IP数据报在传输过程中可能被分片，也可能不被分片。如果被分片，分片后的IP数据报和原来没有分片的IP数据报结构是相同的，即也是由IP头部和IP数据区两个部分组成。
  
  分片后的IP数据报，**数据区是原IP数据报数据区的一个连续部分**，头部是原IP数据报头部的复制，但与原来未分片的IP数据报头部有两点主要不同：标志和片偏移。
  
  将原数据报分片后加入新的报头（报头是原数据报报头的复制），通过网络的不同路径传输到目标主机。提高了效率，当出现错误时的代价较小。
  
  重组——通过`标识`判断是否属于同一数据报；通过`标志`的`MF`判断是否是最后一片；根据`偏移量`确定在数据报中的位置。

### （4）路由转发分片IP数据报

**通过查找路由表，判断是否在当前局域网以及不在局域网时的转发路由是什么（默认路由）。关键是，路由可以同时处在两个不同的局域网中。**

* 若目的主机和当前路由在同一个局域网中（网络号相同），则直接通过本路由的某个接口交付。
* 若目的主机和当前路由不在同一个局域网，但是有和目的主机在同一局域网的路由器在当前局域网。则当前路由器通过路由表查找到转发路由，将数据报转发到转发路由。由转发路由再在目标网络中转发数据报。

### （5）ARP——地址解析协议

* IP	<=============>	MAC

* ARP缓存
* **在缓存中未找到对应MAC时：将自身MAC地址作为源MAC地址，将目的MAC地址设为FF FF FF FF FF FF，封装成MAC帧，在集线器上广播，目标主机收到后返回ICMP报文**

### （6）ICMP协议报文

ICMP（Internet Control Message Protocol）因特网控制报文协议。它是IPv4协议族中的一个子协议，用于IP主机、路由器之间传递**控制消息**。控制消息是在网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然不传输用户数据，但是对于用户数据的传递起着重要的作用。
ICMP协议与ARP协议不同，**ICMP靠IP协议来完成任务，所以ICMP报文中要封装IP头部**。它与传输层协议（如TCP和UDP）的目的不同，一般不用来在端系统之间传送数据，不被用户网络程序直接使用，除了想Ping和Tracert这样的诊断程序。

* ICMP报文格式

  ICMP依赖于IP datagram，ICMP数据区加上至少8B的报头，再加上至少20B的IP数据报报头封装成IP数据报。

![ICMP报文格式](https://i.loli.net/2021/07/11/i7WTR2chNFoznAH.png)

* 两类：ICMP错误报告报文、ICMP查询报文

* ICMP错误报告报文格式：从错误分片IP数据报取出报头，首位各加8字节作为数据区，再加上ICMP错误报告报头。

* ICMP查询报文：

  [PING命令](https://blog.csdn.net/chen1415886044/article/details/110356022)底层是ICMP，调用网络层命令，发送请求与回复报文

  ARP地址解析时，从ARP缓存中没有查找到相应MAC时，在集线器上广播自身IP和MAC以及查找的IP时，对应IP回复时的报文

### （7）路径MTU

* 路径MTU——路径MTU是指一条因特网传输路径中，从源地址到目的地址所经过的“路径”上的所有IP跳的最大传输单元的最小值（取最小值才能满足所有MTU）。或者从另外一个角度来看，就是无需进行分片处理就能穿过这条“路径”的MTU的最大值。

* 路径MTU发现方法——这是确定两个IP主机之间路径最大传输单元的技术，其目的就是为了避免IP分片。首先源地址将数据报的DF位置位（不论多长都不分片），在逐渐增大发送的数据报的大小——路径上任何需要将分组进行分片的设备都会将这种数据报丢弃并返回“数据报过大“的ICMP响应到源地址——这样源主机就”学习“到了无需分片就能通过这条路径的最大的最大传输单元。

* TraceRoute——打印出到达目的IP所经过的所有路由

  Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具。它的原理如下：它受到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包（ 每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签 ），而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器ip。
  Traceroute提取发送 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。

### （8）DNS

* DNS——domain name system，域名系统

* 实现**输入主机名，返回对应IP**的黑盒子。应用程序需要IP时，将主机名传递给当前主机上运行着的DNS客户端，DNS客户端通过查询返回对应IP给应用程序。

* DNS黑盒的内部运作很复杂。

  [DNS解析详细过程1](https://www.zhihu.com/question/23042131)
  
  [DNS解析详细过程2](https://blog.csdn.net/zzg19950824/article/details/79518678)

* 区（Zone）——一个服务器所负责管辖(或有权限)的范围叫做区(zone)。

  采用上述的树状结构，每一个节点都采用一个域名服务器，这样会使得域名服务器的数量太多，使域名服务器系统的运行效率降低。
  各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的**权威（权限）域名服务器**，用来**保存该区中的所有主机到域名IP地址的映射**。顶级域名服务器也可以算作是权威域名服务器，只不过由于其特殊性，我们专门把它划分为一类。因此权威域名服务器通常是指顶级域名以下的管理二级、三级、四级等域名的服务器。

  ![img](D:\WorkSpace\工作笔记\TCP_IP\网络编程.assets\v2-9f88a033ba72d87698ac0c266b7c1943_720w.jpg)

* 本地域名服务器

  电脑上网时IPv4或者IPv6设置中填写的那个DNS。这个有可能是手工指定的或者是DHCP自动分配的

  这类服务器不属于上面的层次结构，当一个主机(个人电脑)发出DNS请求时，查询请求就被发送到本地域名服务器，本地域名服务器负责回答这个查询，或者代替主机向域名空间中不同层次的权威域名服务器查询，再把查询的结果返回给主机。如常用的114.114.114.114和8.8.8.8。

* DNS缓存

  本机上有一个DNS缓存——hosts文件。本地域名服务器、各级域名服务器上都有DNS缓存。本机首先在hosts上找目标主机的IP，找不到的话就向本地域名服务器发出请求，本地域名服务器也先查找DNS缓存，找不到的话再向根域名服务器发出查询，**把查询结果返回的同时也存入缓存备查**。各级域名服务器查询之前都先查找自身的DNS缓存。

* DNS的TTL——这个参数告诉本地DNS服务器，域名缓存的最长时间

  阿里云解析来举例，阿里云解析默认的TTL是10分钟，10分钟的含义是，本地DNS服务器对于域名的缓存时间是10分钟，10分钟之后，本地DNS服务器就会删除这条记录，删除之后，如果有用户访问这个域名，就要重复一遍上述复杂的流程。

* 递归查询和迭代查询

  localhost向本地域名服务器的查询是递归查询，即localhost将查询工作交给了本地域名服务器，本地域名服务器替localhost完成后续查询任务，返回结果给localhost，类似编程语言中的异常向调用处层层抛出。

  本地域名服务器向根域名服务器、顶级域名服务器、权威域名服务器的查询是迭代查询。根域名服务器不是亲自去查询，而是返回对应的顶级域名服务器的IP，由本地域名服务器去查询。

  例：主机m.xyz.com查询y.abc.com

  ![preview](D:\WorkSpace\工作笔记\TCP_IP\网络编程.assets\v2-8285cf5d1ee23f5513f9bc8dd8999ef6_r.jpg)

  

  localhost：m.xyz.com	------------------------------>	本地域名服务器dns.xyz.com	-------------------------------------------> root域名服务器

  ​                                                                                                                                   <------------------------------------------- 对应的顶级域名服务器dns.com的IP	

​                                                                                        本地域名服务器dns.xyz.com	-------------------------------------------> 顶级域名服务器dns.com

​                                                                                        												  <------------------------------------------- 权威域名服务器dns.abc.com的IP

​                                                                                        本地域名服务器dns.xyz.com	------------------------------------------->   权威域名服务器dns.abc.com      

​                                                                                        												  <------------------------------------------- 目标主机y.abc.com的IP

​													目标主机y.abc.com的IP												

​	localhost：m.xyz.com	 <------------------------------------本地域名服务器dns.xyz.com	

## 2. 传输层——建立进程(端口)到进程的通信

在IP地址的基础上添加**端口**再加以封装

### （1）UDP

* 无连接（无逻辑连接），所以可以一对多，多对多，可承担广播、多播

* 不可靠（尽最大可能交付，接收端不返回确认报文）、

* 半双工（发送端和接收端交替发送）

* **面向数据报，应用层数据加上8B报头就直接送往发送缓存**

* 简单快速、耗费资源少。

* **适用于对丢包不敏感的领域：视频、直播、物联网等**

* UDP报文段格式

  伪首部12字节，首部8字节（2字节源端口、2字节目的端口、2字节UDP报文长度、2字节校验和checksum）

  > 1）源端口（2 字节）：发送方端口号
  >
  > 2）目的端口（2 字节 ）：接收方端口号
  >
  > 3）报文长度（2 字节）：UDP 用户数据报的总长度，以字节为单位。
  >
  > 4）校验和（2 字节）：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。
  >
  > 5)   数据区：UDP 的数据部分如果不为偶数需要用 0 填补，就是说，如果数据长度为奇数，数据长度加“1”。

* 校验和

  同IP校验和只计算分片IP数据报报头不同，计算UDP报文段整个部分（伪首部、首部、数据区）

* 应用层传下来的数据到`发送缓存`，传输层从发送缓存取出数据，以UDP协议传输

* **socket=IP：port**

  **端口号长度为2个字节，有效范围是0到65536。**

  IP只指定主机，port指定进程。socket实质是进程间通信
  
  UDPsocket只有目的地址+目的端口

### （2）TCP

* TCP报文段（segment ）格式

  最少20字节的首部

  > 1)	源端口（16位）
  >
  > 2）目的端口（16位）
  >
  > 3） 序号seq（也叫序列号）（32位）
  >
  > 4）确认号ack（32位）
  >
  > 5） 数据偏移（首部长度）（4位）
  >
  > 6）保留位（6位）
  >
  > 7）控制位（6位）
  >
  > > SYN标志位——新建连接。仅在三次握手建立 TCP 连接时有效。
  > >
  > > FIN——释放连接
  > >
  > > ACK——确认标志
  >
  > 8）窗口（16位）
  >
  > 指发送本报文段的一方的接收窗口（而不是自己的发送窗口）。
  >
  > 此字段用来进行流量控制，**这个值是本机期望一次接收的字节数（告知发送方下次期望发送的数据的长度）**，即发送数据的窗口大小。告诉对方在不等待确认的情况下，可以发来多大的数据。这里表示的最大长度是2^16 - 1 = 65535，如需要使用更大的窗口大小，需要使用选项中的窗口扩大因子选项。
  >
  >  9）校验和（16位）
  >
  > 源主机和目的主机计算TCP报文段整个部分（伪首部、首部、数据区）计算校验和。
  >
  > 10）紧急指针（16位）
  >
  > 11）选项、填充字段
  >
  > 12）数据区（长度可变）
  >
  > 数据区MSS（最大报文段长度，不包括段头）：1460B（IP数据报最大长度1500B-IP数据报报头20B-TCP报文段段头最小20B）

* **TCP分组**

  

* TCP socket需要：源地址+源端口、目的地址+目的端口

* 有连接，一对一

* 全双工

* 面向字节，以字节为单位传输

* 可靠传输

  等待确认——序号seq（**随机产生一个值seq**（[这样可避免黑客很容易猜到序列号而发起攻击](https://blog.csdn.net/qq_40910541/article/details/88760627)）、确认号ack（确认应答超时、确认应答丢失）、连续ARQ协议（连续发送、累积确认）

  > ARQ协议：停止等待*ARQ*协议、回退ARQ和连续*ARQ*协议
  >
  > https://blog.csdn.net/jmq_0000/article/details/7299910

  超时重传——超时时间确定公式

* 流量控制——滑动窗口rwnd，**发送端**以3个指针维护四个区域，发送缓冲区。

  > 在确认应答策略中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，这样做有一个比较大的缺点，就是性能比较差，尤其是数据往返的时间长的时候。
  >
  > （1）接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK来通知发送端
  >
  > （2）窗口大小字段越大，说明网络的吞吐率越高
  >
  > （3）窗口大小指的是无需等待确认应答而可以继续发送数据的最大值，即就是说不需要接收端的应答，可以一次连续的发送数据
  >
  > （4）操作系统内核为了维护滑动窗口，需要开辟发送缓冲区，来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉
  >
  > ps：发送缓冲区如果太大，就会有空间开销
  >
  > （5）接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端，发送端收到这个值后，就会减慢自己的发送速度
  >
  > （6）如果接收端发现自己的缓冲区满了，就会将窗口的大小设置为0，此时发送端将不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端
  >
  > （7）在TCP的首部中，有一个16为窗口字段，此字段就是用来存放窗口大小信息的
  >
  > 原文链接：https://blog.csdn.net/borderhz/article/details/117284318
  >
  > 

* 拥塞控制——拥塞窗口cwnd，发送端取rwnd和cwnd较小者作为发送窗口大小。**快速重传、快速恢复**算法设置cwnd长度（字节）

* 连接建立与断开——三次握手、四次挥手

  https://zhuanlan.zhihu.com/p/78244069

  > #### **为什么需要三次握手？**
  >
  > TCP的连接因为是全双工的，也就是Client和Server两端，发送消息两个方向的连接都要建立成功。如果要保证双向连接都成功的话，三次通信是最少的次数了。大于三次的话，后面的次数通信就没有必要了，是在浪费资源。
  >
  > 二次的话，会怎么样，可不可以呢？答案是不可以，我们来看下，下面的场景。
  >
  > 在谈论这个之前，我们先要知道TCP是基于IP协议的，而IP协议是有路由的，IP协议不能够保证先发送的数据先到达，这当中依赖于IP协议底层的网络质量，以及Client与Server之间的路由跳数。
  >
  > Client在发送完Syn消息1，这里称作Syn1之后，假设因为网络原因，Syn1并没有到达Server端，这个时候Client端已经超时，Client之后重新发起SYN消息，这里称作Syn2。结果由于网络原因Syn2先到答Server，Server于是与Client基于Syn2建立了连接，结果没过多久Syn1又到达了Server,Server于是关掉了Syn2建立的那条连接，又重新建立了一条连接。对于Client来说新建立的这条连接是早就过时的，所以Client不会在这条连接上发送任何数据，这就导致了Server端长时间收不到数据，Client新的连接被断掉了。
  >
  > #### **三次握手失败了会怎么样？**
  >
  > 这里要看是在那个阶段失败的，Client在发送SYN之后没有收到ACK消息，Client会进行重传，第一次重传时间5.5-6s之间，第二次重传会是24s，不成功还会继续尝试，伯克利系统在超过75s之后，如果还是不成功，会放弃尝试连接。（备注：这里面的重传时间设置，与底层的定时器设置有过关系，可以参考TCP/IP详解卷1，这里不做详谈。）
  >
  > 如果Server没有收到最后的一次Ack消息，同样的原理，Server也会进行重传第二步的Syn+Ack消息。
  >
  > 四次挥手：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃
  >
  > [MSL、TTL和RTT简介](https://www.cnblogs.com/zhangkele/p/10323588.html)

* ###### 关于 TIME_WAIT 状态的说明

  客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？

  TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器A每次向机器B发送数据包后，都要求机器B”确认“，回传ACK包，告诉机器A我收到了，这样机器A才能知道数据传送成功了。如果机器B没有回传ACK包，机器A会重新发送，直到机器B回传ACK包。

  客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。那么，要等待多久呢？

  **数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为报文最大生存时间（MSL，Maximum Segment Lifetime）。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包。**

### 





## 3. 数据链路层

### （1） MAC帧格式

* 帧头16B：源MAC地址6B，目的MAC地址6B

  



## 4. 总结

[总结](https://blog.csdn.net/liuchengzimozigreat/article/details/100169829)

### （1） [路由器工作原理](https://blog.csdn.net/hhthwx/article/details/78617877)

### （2）  [MAC表、ARP表、路由表](https://blog.csdn.net/bzhxuexi/article/details/44237633)

[路由表、ARP表、MAC表2](https://zhuanlan.zhihu.com/p/139355604)

> 路由表——网络层，选择最短路径，判断下一跳网关是哪个。（用来在**局域网间**寻找下一跳要传送到的局域网的网关）。分为静态路由表和动态路由表，前者由网络管理员设置好，后者是路由器基于路由协议学习。
>
> ARP表——数据链路层，IP→MAC（得到下一跳网关的MAC），将目的MAC地址封装进MAC数据帧。（**局域网内部**起作用，获取目标主机的MAC地址）
>
> MAC表——用于交换机，MAC地址→接口，用于交换机确定目的MAC对应的主机要通过那个接口发送（接口与MAC绑定），实现单播，由交换机负责将数据包发送到某一个设备，而不是将数据包在局域网内广播到所有设备。这样连接在同一个交换机上的设备之间是无法截取发送给另一个设备的数据包的。

### （3）  [详解一次完整的数据包传输过程 -- 层层递进](https://blog.csdn.net/u011563903/article/details/90116368)

> 传输层封装**源端口、目的端口**
>
> 网络层封装**源IP、目的IP**
>
> 数据链路层封装**源MAC、目的MAC**
>
> 层层封装与解封的过程类似于将信件（数据）放入层层信封，信件就是从应用层传下来的数据区，每一层拆开信封后拿出内容都重填“寄件人”（源MAC地址）和“收件人”（目的MAC地址）。某一层的设备只解封到相应层，不会 拆开上一层对应的“内部”的信封，拆开后从信封封面读取该层所需信息。重新封装也是拿一个新的当前层对应的信封，将手里当前的信封装入，并在信封上写上新的发件人、收件人等信息。

### （4） [路由器和交换机的区别](https://blog.csdn.net/baidu_32045201/article/details/78305586)

> 集线器工作在第一层物理层，路由器工作在第三层网络层，交换机工作在第二层数据链路层
>
> 路由器和交换机的主要工作如下：
> **路由器：寻址，转发（依靠 IP 地址）**
> **交换机：过滤，转发（依靠 MAC 地址）**
>
> **每一个路由器与其之下连接的设备，其实构成一个局域网**
> 交换机工作在路由器之下，就是也就是**交换机工作在局域网内**
> 交换机用于**局域网内网的数据转发**
> 路由器用于**连接局域网和外网**
>
> 路由器发送数据——广播
>
> 交换机——单播：一个接口接一个host，若MAC表中有目的MAC对应的交换机接口则直接通过相应接口单播转发到目的host；若MAC表中没有目的MAC对应的接口，则通过所有**非接收接口**进行广播，目的主机接收后返回响应，交换机会将目的主机和接口的对应关系记录到MAC表中，下次发送时就直接向对应接口发送实现单播。

### （5）  集线器、网桥、交换机

![image-20210706151532194](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210706151532194.png)

### （6） 各层封装

* 协议数据单元在应用层、表示层和会话层被称做**数据**(Data)，在传输层被称做**分段**(Segment)，在网络层被称做**包**(Packet)，在数据链路层被称做**帧**(Frame)，在物理层被称做**比特**(Bit)

  TCP segment——应用层数据+端口号（源目端口）

  IP datagram——TCP segment+IP地址（源目IP）

  MAC frame——IP datagram+MAC地址（目的MAC地址）

* 数据包的封装

![image-20210711214319891](https://i.loli.net/2021/07/11/yjXZ9wghmzSLRki.png)

以太网类型——2B，协议类型——1B，MAC帧循环冗余校验——4B

* 应用层协议端口号固定，常用协议端口号如下：

  常用服务	协议	端口号
  POP3	TCP	110
  IMAP	TCP	143
  SMTP	TCP	25
  Telnet	TCP	23
  终端服务	TCP	3389
  PPTP	TCP	1723
  HTTP	TCP	80
  FTP(控制)	TCP	21
  FTP(数据)	TCP	20
  HTTPS	TCP	443
  NTP	UDP	123
  RADIUS	UDP	1645
  DHCP	UDP	67
  DNS	UDP	53
  DNS	TCP	53
  SNMP	UDP	161
  ipsec	UDP	500
  TFTP	UDP	69
  L2TP	UDP	1701

### （7）IP分片与TCP分组

最大传输单元（MTU——每层协议数据区最大长度）。数据大小 > MTU，就需要被分片。

我们的数据经过七层协议的过程中就像包粽子一样，每过一层就需要增加数据的大小，ip层的上层是传输层（tcp/udp ，tcp 的头部为20Byte，udp头部字节是8B）ip层自己的头部需要占20字节，ip层的MTU = 1500Byte - 20 =1480B。ip层传输的数据包最大是1480B, 超过1480Byte的数据，都需要被ip层分片，在达到目的前会自己重组。

又因为，tcp是可靠传输协议，通过超时与重传机制，来保证收到的数据是完整的。因为tcp是可靠传输协议，如果要传输的数据大于 1480 - 20(tcp头部) =1460Byte时，在ip层被分片，而ip层分片会导致，**如果其中的某一个分片丢失，因为tcp层不知道哪个ip数据片丢失，所以就需要重传整个数据段**，这样就造成了很大空间和时间资源的浪费。为了解决这个问题，就需要避免TCP报文被IP分片。所以在传输层就分组，即将TCP报文段分组，数据部分超过MSS（**最大报文长度——TCP数据区最大长度**）的就要分组，这样`分组TCP报文段`到达IP时就不会被分片了。就需要确保到达IP时的数据区长度最长为MTU=1500B-20B（数据链路层的MTU=1500B，所以IP数据报最长为1500B）。所以TCP MSS=MTU-20B-20B=1460B。

**由于udp是不可靠传输的，所以ip分片主要是为了upd服务的**，所以就有了网上的1500 - 20(ip头部) - 8(udp头部) > 1472 的说法，把1472作为ip分片的标准。

---

# Socket初步

Socket技术即利用了计算机网络的原理，封装了五层网络模型，提供了一系列API（函数），来实现以上协议，使得客户端和服务器主机上的进程之间可以互相通信。

[Socket技术详解](https://www.jianshu.com/p/066d99da7cbd)

