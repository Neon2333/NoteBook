# Part 00——注意点收集



## 1. vs code编译报错`__imp_WASartup`等的解决办法

![image-20210827231215022](https://i.loli.net/2021/08/27/mElYtpyM84CV2eU.png)

https://blog.csdn.net/qq_20916555/article/details/50938424

https://www.yht7.com/news/127552

## 2. 127.0.0.1——回送地址

127.0.0.1是回送地址（loopback address），替代当前计算机的IP。

---

# Part 01——C# winform Socket



## 1. DNS解析

### 头文件——System.Net

### （1）主机类——IPHostEntry

* 服务器主机信息的容器，将服务器的URI、IP地址列表（一个URI可能对应好几台服务器，因此也就有好几个IP）、一组别名相关联并封装。

```c#
IPHostEntry hostInfo = Dns.GetHostEntry("www.bing.com");	//将uri "www.bing.com"经过DNS解析，返回存储着主机信息的	//IPHostEntry实例
```

#### 属性

> * AddressList——获取/设置主机的IP地址列表
>
>   ```C#
>   public IPAddress[] AddressList	{get; set;}
>   ```
>  
>     ```c#
>   // Get 'IPHostEntry' object containing information like host name, IP addresses, aliases for a host.
>           IPHostEntry hostInfo = Dns.GetHostByName(hostString);
>           Console.WriteLine("Host name : " + hostInfo.HostName);
>           Console.WriteLine("IP address List : ");
>           for(int index=0; index < hostInfo.AddressList.Length; index++)
>           {
>               Console.WriteLine(hostInfo.AddressList[index]);
>           }
>     ```
>   
> * HostName——获取主机的DNS名称/URI
>
>   ```C#
>  public string HostName { get; set; }
>   ```
> 
> * Aliases——获取主机别名
>
>   ```c#
>    public string[] Aliases { get; set; }
>   ```

### （2）IP地址类——IPAddress

获取服务器的IP地址相关信息。

Tostring()转化为点分十进制形式的IP。

#### 属性

> * Address——十进制形式IP（已过时）
> * AddressFamily——IP地址使用的地址族

### （3）Dns类

该类提供简单的DNS解析功能。

#### 方法

> * GetHostEntry(string)——将**主机名或 IP 地址**解析为IPHostEntry实例。（Resolve已过时）
>
> * GetHostName()——获取本地计算机主机名
>
> * GetHostAddresses(string)——返回指定主机的 Internet 协议 (IP) 地址
>
>   ```c#
>   public static System.Net.IPAddress[] GetHostAddresses (string hostNameOrAddress);
>   ```
>
> * BeginGetHostEntry(String, AsyncCallback, Object)——将主机名或 IP 地址**异步**解析为IPHostEntry实例
>
>   ```C#
>   public static IAsyncResult BeginGetHostEntry (string hostNameOrAddress, AsyncCallback? requestCallback, object? stateObject);
>   ```

```c#
 private void button_addrEx_Click(object sender, EventArgs e)
        {
            IPHostEntry host = Dns.GetHostEntry(textBox_uri.Text);
            //foreach(IPAddress addr in host.AddressList)
            //{
            //    long ip = addr.Address;
            //    textBox_ip.Text += ip.ToString() + "\r\n";
            //    textBox_ip.Text += addr.ToString() + "\r\n";
            //}
            textBox_host.Text = host.HostName;
            IPAddress[] ips= Dns.GetHostAddresses(textBox_uri.Text);
            foreach(IPAddress addr in ips)
            {
                long ip = addr.Address;
                textBox_ip.Text += ip.ToString() + "\r\n";	//Windows中换行符是\r\n
                textBox_ip.Text += addr.ToString() + "\r\n";
            }
        }
```



## 2. TCP

### （1）头文件——System.Net.Sockets

### （2）NetworkStream类——为网络访问提供数据的基础流

#### 构造

```C#
public NetworkStream (Socket socket);
```

```C#
public NetworkStream (Socket socket, bool ownsSocket);
/*
Socket
Socket，NetworkStream 使用它来发送和接收数据。
ownsSocket
Boolean
设置为 true 可指示 NetworkStream 将拥有 Socket；否则为 false。
*/
```

```C#
// Examples for constructors that do not specify file permission.

// Create the NetworkStream for communicating with the remote host.
NetworkStream myNetworkStream;

if (networkStreamOwnsSocket){
     myNetworkStream = new NetworkStream(mySocket, true);
}
else{
     myNetworkStream = new NetworkStream(mySocket);
}
```

#### 方法

> * Read——从NetworkStream读取数据，并将其存储到字节数组中
>
>   ```C# 
>   public override int Read (byte[] buffer, int offset, int size);
>   ```
>
>   > - buffer——Byte类型的数组，它是内存中用于存储从NetworkStream读取的数据的位置。
>   >
>   > - offset——buffer 中数据存储的起始位置
>   >
>   > - size——要从中读取的字节数
>   > - 返回值——从NetworkStream中实际读取的字节数
>
> * Write——从字节数组的指定范围向NetworkStream写入数据
>
>   ```C#
>   public override void Write (byte[] buffer, int offset, int size);
>   ```
>
>   > * buffer——存储要写入流的数据
>   > * offset——buffer要写入数据的起始位置
>   > * size——buffer要写入字节长度
>
> * ReadByte——从NetworkStream中读取一个字节，并将流内的位置向前提升一个字节，或者如果已到达流结尾，则返回 -1
>
>   ```C#
>   public override int ReadByte ();
>   ```
>
> * WriteByte——将一个字节写入 NetworkStream内的当前位置，并将流内的位置向前提升一个字节
>
>   ```C#
>   public override void WriteByte (byte value);	//value要写入流当前位置的一个字节
>   ```

#### 属性

> * Length
> * Socket

### （3）TcpClient类——提供客户端连接

#### 构造

```C#
public TcpClient (string hostname, int port);	//初始化 TcpClient 类的新实例并连接到指定主机上的指定端口。
```

> - hostname——要连接到的远程主机的 DNS 名。
>
> - port——要连接到的远程主机的端口号。

```C#
//Creates a TCPClient using host name and port.
TcpClient tcpClientB = new TcpClient ("www.contoso.com", 11000);
```

#### 方法

> * Connect——客户端连接到指定IP和端口的远程主机
>
>   ```C#
>   public void Connect (System.Net.IPAddress address, int port);
>   ```
>
>   > IPAddress——你打算连接到的主机的 IPAddress。
>   > port——要连接到的端口号。
>
>   ```C#
>   public void Connect (System.Net.IPAddress[] ipAddresses, int port);
>   ```
>
>   > ipAddresses——要连接到的主机的 IPAddress 数组。
>   > port——要连接到的端口号。
>
>   ```C#
>   //Uses the IP address and port number to establish a socket connection.
>   TcpClient tcpClient = new TcpClient ();
>   IPAddress ipAddress = Dns.GetHostEntry ("www.contoso.com").AddressList[0];
> <<<<<<< Updated upstream
>
> =======
>
> >>>>>> Stashed changes
>   tcpClient.Connect (ipAddress, 11003);
>   
>   ```
>
> 
>
> * GetStream——返回用于发送/接收数据的NetworkStream
>
>   ```C#
>   public System.Net.Sockets.NetworkStream GetStream ();
>   ```
>
>   ```C#
>   TcpClient tcpClient = new TcpClient ();
>   <<<<<<< Updated upstream
>   
>   // Uses the GetStream public method to return the NetworkStream.
>   NetworkStream netStream = tcpClient.GetStream ();
>
> =======
>
>   // Uses the GetStream public method to return the NetworkStream.
>   NetworkStream netStream = tcpClient.GetStream ();
>
> >>>>>> Stashed changes
>   if (netStream.CanWrite)
>   {
>       Byte[] sendBytes = Encoding.UTF8.GetBytes ("Is anybody there?");
>       netStream.Write (sendBytes, 0, sendBytes.Length);
>   }
>   else
>   {
>       Console.WriteLine ("You cannot write data to this stream.");
>       tcpClient.Close ();
> <<<<<<< Updated upstream
>
> =======
>
> >>>>>> Stashed changes
>       // Closing the tcpClient instance does not close the network stream.
>       netStream.Close ();
>       return;
>   }
> <<<<<<< Updated upstream
>
> =======
>
> >>>>>> Stashed changes
>   if (netStream.CanRead)
>   {
>       // Reads NetworkStream into a byte buffer.
>       byte[] bytes = new byte[tcpClient.ReceiveBufferSize];
> <<<<<<< Updated upstream
>
>       // Read can return anything from 0 to numBytesToRead.
>       // This method blocks until at least one byte is read.
>       netStream.Read (bytes, 0, (int)tcpClient.ReceiveBufferSize);
>     
>       // Returns the data received from the host to the console.
>       string returndata = Encoding.UTF8.GetString (bytes);
>
> =======
>
>       // Read can return anything from 0 to numBytesToRead.
>       // This method blocks until at least one byte is read.
>       netStream.Read (bytes, 0, (int)tcpClient.ReceiveBufferSize);
>     
>       // Returns the data received from the host to the console.
>       string returndata = Encoding.UTF8.GetString (bytes);
>
> >>>>>> Stashed changes
>       Console.WriteLine ("This is what the host returned to you: " + returndata);
>   }
>   else
>   {
>       Console.WriteLine ("You cannot read data from this stream.");
>       tcpClient.Close ();
> <<<<<<< Updated upstream
>
> =======
>
> >>>>>> Stashed changes
>       // Closing the tcpClient instance does not close the network stream.
>       netStream.Close ();
>       return;
>   }
>   netStream.Close();
>   
>   ```
>
> 
>
> * Close——释放TCPClient实例，不关闭TCP连接
>
>   ```c#
>   public void Close ();
>   ```

```C#
static void Connect(String server, String message)
{
  try
  {
    // Create a TcpClient.
    // Note, for this client to work you need to have a TcpServer
    // connected to the same address as specified by the server, port
    // combination.
    Int32 port = 13000;
    TcpClient client = new TcpClient(server, port);

    // Translate the passed message into ASCII and store it as a Byte array.
    Byte[] data = System.Text.Encoding.ASCII.GetBytes(message);

    // Get a client stream for reading and writing.
   //  Stream stream = client.GetStream();

    NetworkStream stream = client.GetStream();

    // Send the message to the connected TcpServer.
    stream.Write(data, 0, data.Length);

    Console.WriteLine("Sent: {0}", message);

    // Receive the TcpServer.response.

    // Buffer to store the response bytes.
    data = new Byte[256];

    // String to store the response ASCII representation.
    String responseData = String.Empty;

    // Read the first batch of the TcpServer response bytes.
    Int32 bytes = stream.Read(data, 0, data.Length);	//bytes是从stream中实际读取的字节数
    responseData = System.Text.Encoding.ASCII.GetString(data, 0, bytes);
    Console.WriteLine("Received: {0}", responseData);

    // Close everything.
    stream.Close();
    client.Close();
  }
  catch (ArgumentNullException e)
  {
    Console.WriteLine("ArgumentNullException: {0}", e);
  }
  catch (SocketException e)
  {
    Console.WriteLine("SocketException: {0}", e);
  }

  Console.WriteLine("\n Press Enter to continue...");
  Console.Read();
}
```



### （4）TCPListener类——服务器端监听

在指定的本地IP和端口号上监听客户端的连接

#### 构造

```C#
public TcpListener (System.Net.IPAddress localaddr, int port);
```

> localaddr——本地IP
>
> port——监听的端口

```C#
TcpListener server=null;
Int32 port = 13000;
IPAddress localAddr = IPAddress.Parse("127.0.0.1");
server = new TcpListener(localAddr, port);
```



#### 方法

> * Start——服务器端启动监听客户端的连接请求
>
>   ```c#
>   public void Start ();
>   ```
>
> * Stop——关闭监听
>
>   ```C#
>   public void Stop ();
>   ```
>
> * AcceptSocket——接受客户端的连接请求，并返回用于收发数据的Socket
>
>   需要先Start监听
>
>   ```C#
>   public System.Net.Sockets.Socket AcceptSocket ();	
>   ```
>
>   ```C#
>   // Accepts the pending client connection and returns a socket for communciation.
>              Socket socket = tcpListener.AcceptSocket();
>              Console.WriteLine("Connection accepted.");
>
>              string responseString = "You have successfully connected to me";
>
>              //Forms and sends a response string to the connected client.
>              Byte[] sendBytes = Encoding.ASCII.GetBytes(responseString);
>              int i = socket.Send(sendBytes);
>              Console.WriteLine("Message Sent /> : " + responseString);
>   ```
>
> * AccecptTcpClient——接受挂起的客户端连接请求
>
>   ```C#
>   public System.Net.Sockets.TcpClient AcceptTcpClient ();
>   ```
>
>   > 返回值——TcpClient 
>
>   ```C#
>   /**
>   * The following sample is intended to demonstrate how to use a
>   * TcpListener for synchronous communcation with a TCP client
>   * It creates a TcpListener that listens on the specified port (13000).
>   * Any TCP client that wants to use this TcpListener has to explicitly connect
>   * to an address obtained by the combination of the server
>   * on which this TcpListener is running and the port 13000.
>   * This TcpListener simply echoes back the message sent by the client
>   * after translating it into uppercase.
>   * Refer to the related client in the TcpClient class.
>   */
>   using System;
>   using System.Text;
>   using System.IO;
>   using System.Net;
>   using System.Net.Sockets;
>   using System.Threading;
>   <<<<<<< Updated upstream
>             
>   public class TcpListenerSample
>   {
>
> =======
>
>   public class TcpListenerSample
>   {
>
> >>>>>> Stashed changes
>       static void Main(string[] args)
>       {
>           try
>           {
>               // set the TcpListener on port 13000
>               int port = 13000;
>               TcpListener server = new TcpListener(IPAddress.Any, port);
> <<<<<<< Updated upstream
>
>               // Start listening for client requests
>               server.Start();
>                         
>               // Buffer for reading data
>               byte[] bytes = new byte[1024];
>               string data;
>
> =======
>
>               // Start listening for client requests
>               server.Start();
>                         
>               // Buffer for reading data
>               byte[] bytes = new byte[1024];
>               string data;
>
> >>>>>> Stashed changes
>               //Enter the listening loop
>               while (true)
>               {
>                   Console.Write("Waiting for a connection... ");
> <<<<<<< Updated upstream
>
> =======
>
> >>>>>> Stashed changes
>                   // Perform a blocking call to accept requests.
>                   // You could also use server.AcceptSocket() here.
>                   TcpClient client = server.AcceptTcpClient();
>                   Console.WriteLine("Connected!");
> <<<<<<< Updated upstream
>
>                   // Get a stream object for reading and writing
>                   NetworkStream stream = client.GetStream();
>                         
>                   int i;
>                         
>                   // Loop to receive all the data sent by the client.
>                   i = stream.Read(bytes, 0, bytes.Length);
>
> =======
>
>                   // Get a stream object for reading and writing
>                   NetworkStream stream = client.GetStream();
>                         
>                   int i;
>                         
>                   // Loop to receive all the data sent by the client.
>                   i = stream.Read(bytes, 0, bytes.Length);
>
> >>>>>> Stashed changes
>                   while (i != 0)
>                   {
>                       // Translate data bytes to a ASCII string.
>                       data = System.Text.Encoding.ASCII.GetString(bytes, 0, i);
>                       Console.WriteLine(String.Format("Received: {0}", data));
> <<<<<<< Updated upstream
>
>                       // Process the data sent by the client.
>                       data = data.ToUpper();
>                         
>                       byte[] msg = System.Text.Encoding.ASCII.GetBytes(data);
>                         
>                       // Send back a response.
>                       stream.Write(msg, 0, msg.Length);
>                       Console.WriteLine(String.Format("Sent: {0}", data));
>                         
>                       i = stream.Read(bytes, 0, bytes.Length);
>                   }
>
> =======
>
>                       // Process the data sent by the client.
>                       data = data.ToUpper();
>                         
>                       byte[] msg = System.Text.Encoding.ASCII.GetBytes(data);
>                         
>                       // Send back a response.
>                       stream.Write(msg, 0, msg.Length);
>                       Console.WriteLine(String.Format("Sent: {0}", data));
>                         
>                       i = stream.Read(bytes, 0, bytes.Length);
>                   }
>
> >>>>>> Stashed changes
>                   // Shutdown and end connection
>                   client.Close();
>               }
>           }
>           catch (SocketException e)
>           {
>               Console.WriteLine("SocketException: {0}", e);
>           }
> <<<<<<< Updated upstream
>
> =======
>
> >>>>>> Stashed changes
>           Console.WriteLine("Hit enter to continue...");
>           Console.Read();
>       }
>   }
>   
>   ```
>
> 

```C#
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;

class MyTcpListener
{
  public static void Main()
  {
    TcpListener server=null;
    try
    {
      // Set the TcpListener on port 13000.
      Int32 port = 13000;
      IPAddress localAddr = IPAddress.Parse("127.0.0.1");

      // TcpListener server = new TcpListener(port);
      server = new TcpListener(localAddr, port);

      // Start listening for client requests.
      server.Start();

      // Buffer for reading data
      Byte[] bytes = new Byte[256];
      String data = null;

      // Enter the listening loop.
      //循环接收客户端的连接请求
      while(true)
      {
        Console.Write("Waiting for a connection... ");

        // Perform a blocking call to accept requests.
        // You could also use server.AcceptSocket() here.	也可使用server.AcceptSocket()
        TcpClient client = server.AcceptTcpClient();	//阻塞，等待客户端连接
        Console.WriteLine("Connected!");

        data = null;

        // Get a stream object for reading and writing
        NetworkStream stream = client.GetStream();

        int i;

        // Loop to receive all the data sent by the client.
        while((i = stream.Read(bytes, 0, bytes.Length))!=0)
        {
          // Translate data bytes to a ASCII string.
          data = System.Text.Encoding.ASCII.GetString(bytes, 0, i);
          Console.WriteLine("Received: {0}", data);	//显示从服务器接受的数据

          // Process the data sent by the client.
          data = data.ToUpper();

          byte[] msg = System.Text.Encoding.ASCII.GetBytes(data);

          // Send back a response.
          stream.Write(msg, 0, msg.Length);	
          Console.WriteLine("Sent: {0}", data);	//将从服务器接收的字符串，变为大写，发送回服务器
        }

        // Shutdown and end connection
        client.Close();
      }
    }
    catch(SocketException e)
    {
      Console.WriteLine("SocketException: {0}", e);
    }
    finally
    {
       // Stop listening for new clients.
       server.Stop();
    }

    Console.WriteLine("\nHit enter to continue...");
    Console.Read();
  }
}
```



### （5）Socket类

不同主机间的进程进行互相通信的端点。通信时至少需要一对socket，一个在客户端一个在服务端，一个Socket类实例包含了客户端端点或服务器端点的socket信息

### 构造

```C#
public Socket (AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
```

> * addressFamily——地址族
>
>   > AddressFamily——enum
>   >
>   > * InterNetwork——IPv4
>   > * InterNetworkV6——IPv6
>
>   ```C#
>   using System;
>   using System.Text;
>   using System.IO;
>   using System.Net;
>   using System.Net.Sockets;
>   <<<<<<< Updated upstream
>             
>   public class Sample
>   {
>
> =======
>
>   public class Sample
>   {
>
> >>>>>> Stashed changes
>     public static string DoSocketGet(string server)
>     {
>       //Set up variables and String to write to the server.
>       Encoding ASCII = Encoding.ASCII;
>       string Get = "GET / HTTP/1.1\r\nHost: " + server +
>                    "\r\nConnection: Close\r\n\r\n";
>       Byte[] ByteGet = ASCII.GetBytes(Get);
>       Byte[] RecvBytes = new Byte[256];
>       String strRetPage = null;
> <<<<<<< Updated upstream
>
>       // IPAddress and IPEndPoint represent the endpoint that will
>       //   receive the request.
>       // Get first IPAddress in list return by DNS.
>                         
>       try
>       {
>
> =======
>
>       // IPAddress and IPEndPoint represent the endpoint that will
>       //   receive the request.
>       // Get first IPAddress in list return by DNS.
>                         
>       try
>       {
>
> >>>>>> Stashed changes
>         // Define those variables to be evaluated in the next for loop and
>         // then used to connect to the server. These variables are defined
>         // outside the for loop to make them accessible there after.
>         Socket s = null;
>         IPEndPoint hostEndPoint;
>         IPAddress hostAddress = null;
>         int conPort = 80;
> <<<<<<< Updated upstream
>
> =======
>
> >>>>>> Stashed changes
>         // Get DNS host information.
>         IPHostEntry hostInfo = Dns.GetHostEntry(server);
>         // Get the DNS IP addresses associated with the host.
>         IPAddress[] IPaddresses = hostInfo.AddressList;
> <<<<<<< Updated upstream
>
> =======
>
> >>>>>> Stashed changes
>         // Evaluate the socket and receiving host IPAddress and IPEndPoint.
>         for (int index=0; index<IPaddresses.Length; index++)
>         {
>           hostAddress = IPaddresses[index];
>           hostEndPoint = new IPEndPoint(hostAddress, conPort);	//构造IPEndPoint
>
>
>           // Creates the Socket to send data over a TCP connection.
>           s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp );
>
>
>           // Connect to the host using its IPEndPoint.
>           s.Connect(hostEndPoint);
> <<<<<<< Updated upstream
>
> =======
>
> >>>>>> Stashed changes
>           if (!s.Connected)
>           {
>             // Connection failed, try next IPaddress.
>             strRetPage = "Unable to connect to host";
>             s = null;
>             continue;
>           }
> <<<<<<< Updated upstream
>
>           // Sent the GET request to the host.
>           s.Send(ByteGet, ByteGet.Length, 0);
>
> =======
>
>           // Sent the GET request to the host.
>           s.Send(ByteGet, ByteGet.Length, 0);
>
> >>>>>> Stashed changes
>         } // End of the for loop.
>
>
>         // Receive the host home page content and loop until all the data is received.
>         Int32 bytes = s.Receive(RecvBytes, RecvBytes.Length, 0);
>         strRetPage = "Default HTML page on " + server + ":\r\n";
>         strRetPage = strRetPage + ASCII.GetString(RecvBytes, 0, bytes);
> <<<<<<< Updated upstream
>
> =======
>
> >>>>>> Stashed changes
>         while (bytes > 0)
>         {
>           bytes = s.Receive(RecvBytes, RecvBytes.Length, 0);
>           strRetPage = strRetPage + ASCII.GetString(RecvBytes, 0, bytes);
>         }
> <<<<<<< Updated upstream
>
>       } // End of the try block.
>
> =======
>
>       } // End of the try block.
>
> >>>>>> Stashed changes
>       catch(SocketException e)
>       {
>         Console.WriteLine("SocketException caught!!!");
>         Console.WriteLine("Source : " + e.Source);
>         Console.WriteLine("Message : " + e.Message);
>       }
>       catch(ArgumentNullException e)
>       {
>         Console.WriteLine("ArgumentNullException caught!!!");
>         Console.WriteLine("Source : " + e.Source);
>         Console.WriteLine("Message : " + e.Message);
>       }
>       catch(NullReferenceException e)
>       {
>         Console.WriteLine("NullReferenceException caught!!!");
>         Console.WriteLine("Source : " + e.Source);
>         Console.WriteLine("Message : " + e.Message);
>       }
>       catch(Exception e)
>       {
>         Console.WriteLine("Exception caught!!!");
>         Console.WriteLine("Source : " + e.Source);
>         Console.WriteLine("Message : " + e.Message);
>       }
> <<<<<<< Updated upstream
>
> =======
>
> >>>>>> Stashed changes
>       return strRetPage;
>   }
>      public static void Main()
>      {
>         Console.WriteLine(DoSocketGet("localhost"));
>      }
>    }
>   
>   ```
>
>   * socketType——socket类型
>
>     > * SocketType——enum
>     > * Dgram——数据报socket
>     > * Stream——流socket
>
>   ```C#
>   //Creates the Socket for sending data over TCP.
>   Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Stream,
>      ProtocolType.Tcp );
> 
>   // Connects to host using IPEndPoint.
>   s.Connect(EPhost);
>   if (!s.Connected)
>   {
>      strRetPage = "Unable to connect to host";
>   }
>   // Use the SelectWrite enumeration to obtain Socket status.
>    if(s.Poll(-1, SelectMode.SelectWrite)){
>         Console.WriteLine("This Socket is writable.");
>    }
>    else if (s.Poll(-1, SelectMode.SelectRead)){
>          Console.WriteLine("This Socket is readable." );
>    }
>    else if (s.Poll(-1, SelectMode.SelectError)){
>         Console.WriteLine("This Socket has an error.");
>    }
>   ```
>
> 
>
> * [protocolType](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.protocoltype?view=net-5.0)——协议
>
>   > * ProtocolType——enum
>   > * IPv4
>   > * IPv6
>   > * Tcp
>   > * Udp
>   > * Icmp
>   > * Igmp

#### 方法

> * 



## 3. HTTP——Web服务器

### （1）WebClient

提供将数据发送到指定Uri和从指定Uri获取数据的方法

```C#
WebClient client = new WebClient();
Stream data = client.OpenRead(textBoxUri.Text);
StreamReader reader = new StreamReader(data);
textBox_content.Text = reader.ReadtoEnd();
reader.close();
data.close();
```

### （2）WebRequest



### （3）WebResponse



### （4）浏览器控件

![image-20210913223432788](https://i.loli.net/2021/09/13/5X7Ioh4H9jmTbzP.png)

```c#
 private void button1_Click(object sender, EventArgs e)
 {
 	webBrowser1.Navigate(textBox_searchUri.Text, false);
 }
```

![image-20210914195241060](https://i.loli.net/2021/09/14/nCKRIspNy159MJr.png)

---

# Part 02——C/C++ Socket

[Socket技术详解](https://www.jianshu.com/p/066d99da7cbd)

## 1. 文件IO和ANSI标准IO

https://blog.csdn.net/owen7500/article/details/53263981

文件IO——OS提供的底层IO，没有缓冲

标准IO——封装了缓冲机制，调用OS底层IO的IO

---

## 2. 常用头文件

https://www.cnblogs.com/wannable/p/5910968.html

```C++
sys/types.h：数据类型定义

sys/socket.h：提供socket函数及数据结构

netinet/in.h：定义数据结构sockaddr_in

arpa/inet.h：提供IP地址转换函数

netdb.h：提供设置及获取域名的函数

sys/ioctl.h：提供对I/O控制的函数

sys/poll.h：提供socket等待测试机制的函数
```

```C++
unistd.h：提供通用的文件、目录、程序及进程操作的函数
 
errno.h：提供错误号errno的定义，用于错误处理
 
fcntl.h：提供对文件控制的函数
 
time.h：提供有关时间的函数
 
crypt.h：提供使用DES加密算法的加密函数
 
pwd.h：提供对/etc/passwd文件访问的函数
 
shadow.h：提供对/etc/shadow文件访问的函数
 
pthread.h：提供多线程操作的函数
 
signal.h：提供对信号操作的函数
 
sys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数
```

```C++
//常用结构体
struct sockadd {
unsigned short sa_family;
char sa_data[14];
}

struct sockaddr_in {
short int sin_family;  //AF_INET
unsigned short int sin_port; //网络字节顺序
struct in_addr sin_addr;   //struct in_addr { unsigned long s_addr; }
unsigned char sin_zero[8];
}
```



---

## 3. server--->client的基本流程

### Linux

#### （1）server

> ##### 创建套接字——socket
>
> ```c
> //Linux
> #include<stdlib.h>
> #include<stdio.h>
> #include<sys/socket.h>
> int socket(int domain, int type, int protocol);	//成功返回文件描述符fd，失败返回-1
> ```
>
> ```c
> int fd = socket(PF_INET, SOCK_DGRAM, 0);
> ```
>
> ##### 套接字绑定地址——bind
>
> ```c
> //Linux
> #include<sys/socket.h>
> int bind(int sock, struct sockaddr* server_addr, socklen_t addrlen);	//成功返回0，失败返回-1
> ```
>
> ```c
> struct sockaddr_in serv_addr;	//定义server地址为sockaddr_in类型
> memset(&serv_addr,0,sizeof(serv_addr));	//置0
> serv_addr.sin_family=AF_INET;	//IPv4
> serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);	//绑定IP地址，INADDR_ANY表示所有网卡的IP
> serv_addr.sin_port=htons(atoi(argv[1]));	//命令行第2个参数为server监听的端口
> if(bind(sock,(struct sockaddr*)&serv_addr, sizeof(serv_addr))==-1){
> serv_bindHandling();
> }
> ```
>
> * **INADDR_ANY**
>
> > NADDR_ANY
> > 转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。
> > 比如一台电脑有3块网卡，分别连接三个网络，那么这台电脑就有3个ip地址了，如果某个应用程序需要监听某个端口，那他要监听哪个网卡地址的端口呢？
> >
> > 如果绑定某个具体的ip地址，你只能监听你所设置的ip地址所在的网卡的端口，其它两块网卡无法监听端口，如果我需要三个网卡都监听，那就需要绑定3个ip，也就等于需要管理3个套接字进行数据交换，这样岂不是很繁琐？
> >
> > 所以出现INADDR_ANY，你只需绑定INADDR_ANY，管理一个套接字就行，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
>
> * **htonl——将主机的32位无符号长整形数转换成网络字节顺序**
>
> ```c
> uint32_t htonl(uint32_t hostlong);
> ```
>
> * **htons——将主机的16位无符号短整形数转换成网络字节顺序**
>
> ```c
> uint16_t htonl(uint16_t hostshort);
> ```
>
> * **atoi——把字符串转成整型数，跳过空字符。字符不能转成int或空字符时，无法转换时返回0。**
>
> ```c
> int atoi(const char *nptr); 
> ```
>
> **网络字节序**
>
> > 所谓网络字节顺序（大尾顺序）就是指一个数在内存中存储的时候“高对低，低对高”（即一个数的高位字节存放于低地址单元，低位字节存放在高地址单元中）。但是计算机的内存存储数据时有可能是大尾顺序或者小尾顺序。
> >
> > 先举个例子：
> > int a = 0x403214;
> > int b = htonl(a);
> > 我在VC++6.0调试这段代码，发现
> > &a的值为：0x0012ff44
> > 其中0x0012ff44、0x0012ff45、0x0012ff46、0x0012ff47这四个单元的值依次为：14、32、40、00，即0x403214这个数的高位部分存放在高位地址中，低位部分存放在低位地址中，即小尾顺序。
> > &b的值为：0x0012ff40
> > 其中0x0012ff40、0x0012ff41、0x0012ff42、0x0012ff43这四个单元的值依次为：00、40、32、14，即把原数0x403214的高位部分存放在低位地址中，低位部分存放在高位地址中。
> > 由此可见，如果一个数以小尾顺序存储，经htonl函数调用后这个数的高地位字节会完全颠倒过来成为一个新的数。这个新的数在机器内部其实还是以小尾顺序存储的，但是相对于原来的数而言相当于是变成大尾顺序的了。
> > long型的0x40写完整为:0x 00 00 00 40，共四个字节，调用htonl后四个字节颠倒顺序，为0x 40 00 00 00。
> > 同样，0x40 00 00 00调用htonl后变为0x 00 00 00 40，即0x40
>
> * 转为监听状态——Listen
>
>   ```c
>   //Linux
>   #include<sys/socket.h>
>   int listen(int sock, int backlog);	//成功返回0，失败返回-1
>   ```
>
>   > backlog——服务器接受的请求队列的长度。当有多个客户端同时请求时，服务端无法对所有进行处理，设置队列将请求放入其中，backlog设置队列长度。backlog=10，若来20个请求，则后面10个会被server拒绝不会给对应的client发送rst，这10个client将继续发送TCP SYN，带队列中有请求通过三次握手建立了TCP连接将会从队列中移到另一个队列中。空出位置才能供后续请求移入。
>
> * 阻塞接收消息——accept
>
>   ```c
>   //Linux
>   #include<sys/socket.h>
>   int accept(int sock, struct sockaddr* client_addr, socklen_t* addrlen);	//成功返回文件描述符fd，失败返回-1
>   ```
>
>   ```c
>   struct sockaddr_in serv_addr;
>   int clnt_addr_size = sizeof(clnt_addr);
>   if(accept(sock,(struct sockaddr_in*)&clnt_addr, &clnt_addr_size)==-1){
>       serv_acceptHandling();
>   }
>   ```
>
> 

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(char *message);

int main(int argc, char *argv[])
{
	int serv_sock;
	int clnt_sock;

	struct sockaddr_in serv_addr;
	struct sockaddr_in clnt_addr;
	socklen_t clnt_addr_size;

	char message[]="Hello World!";
	
	if(argc!=2){
		printf("Usage : %s <port>\n", argv[0]);
		exit(1);
	}
	
	serv_sock=socket(PF_INET, SOCK_STREAM, 0);
	if(serv_sock == -1)
		error_handling("socket() error");
	
	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family=AF_INET;
	serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);
	serv_addr.sin_port=htons(atoi(argv[1]));
	
	if(bind(serv_sock, (struct sockaddr*) &serv_addr, sizeof(serv_addr))==-1 )
		error_handling("bind() error"); 
	
	if(listen(serv_sock, 5)==-1)
		error_handling("listen() error");
	
	clnt_addr_size=sizeof(clnt_addr);  
	clnt_sock=accept(serv_sock, (struct sockaddr*)&clnt_addr,&clnt_addr_size);
	if(clnt_sock==-1)
		error_handling("accept() error");  
	
	write(clnt_sock, message, sizeof(message));
	close(clnt_sock);	
	close(serv_sock);
	return 0;
}

void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```



#### （2）client

> * 创建套接字
>
> * 连接server——connect
>
>   ```c
>   //Linux
>   struct sockaddr_in serv_addr;
>   memset(&serv_addr,0,sizeof(serv_addr));
>
>   serv_addr.sin_family=AF_INET;
>   serv_addr.sin_addr.s_addr=inet_addr(argv[1]);	//server这里是htonl(INADDR_ANY)
>   serv_addr.sin_port=htons(atoi(argv[2]));
>
>   int connect(int sock, struct sockaddr* server_addr,socklen_t addrlen);	//成功返回0，失败返回-1
>   ```
>
> * 读写数据——IO
>
>   ```c
>   //打开文件
>   #include<sys/types.h>
>   #include<sys/stat.h>
>   #include<fcntl.h>
>   int open(const char* filePath, int flag);	//成功返回文件描述符fd，失败返回-1
>   ```
>
>   > flag——打开模式
>   >
>   > ![image-20210821220713441](https://i.loli.net/2021/08/21/Ehwz9ZHdvrbUeDa.png)
>
>   ```c
>   //关闭文件
>   //关闭文件、套接字都是该函数
>   #include<unistd.h>
>   int close(int fd)	//成功返回0，失败返回-1
>   ```
>
>   ```c
>   //写入文件
>   #include<unistd.h>
>   ssize_t write(int fd, const void* buf, size_t nbytes);	//成功返回写入的字节数，失败返回-1
>   //size_t是由typedef定义的unsigned int，ssize_t是signed int
>   ```
>
>   > fd——文件描述符
>   >
>   > buf——缓存待写入数据的内存
>   >
>   > nbytes——要写入的数据的字节数
>
>   ```c
>   int fd = open("C:\\Users\\25224\\Desktop\\test.dat",O_RDONLY|O_APPEND);
>   if(fd==-1){
>       open_handling();
>   }
>   const char buf[]="this is a open file test..";
>   if(write(fd, buf, sizeof(buf))==-1){
>       write_handling();
>   }
>   close(fd);
>   ```
>
>   ```c
>   //读取文件
>   #include<unistd.h>
>   ssize_t read(int fd, void* buf, size_t nbytes);	//成功返回读取的字节数，失败返回-1
>   ```
>
>   > fd——文件描述符
>   >
>   > buf——保存读取数据的内存
>   >
>   > nbytes——读取的最大字节数
>
>   ```c
>   #define BUF_SIZE 100;
>   int fd = open("C:\\Users\\25224\\Desktop\\test.dat",O_RDONLY);
>   if(fd==-1){
>       open_handling();
>   }
>   char buf[BUF_SIZE]={0};
>   if(read(fd, buf, sizeof(buf))==-1){
>       read_handling();
>   }
>   ```
>
> 

### Windows

#### （1）server

```c
//Windows
#include<winsock2.h>
SOCKET socket(int af, int type, int protocol);	//失败返回INVALID_SOCKET
```

```c
//Windows
#include<winsock2.h>
int bind(SOCKET s, const struct sockaddr* name, int namelen);	//成功返回0，失败返回SOCKET_ERROR
```

```c
//Windows
int listen(SOCKET s, int backlog);	//成功返回0，失败返回SOCKET_ERROR
```

```c
//Windows
SOCKET accept(SOCKET s, struct sockaddr* server_addr, int* addrlen);	//成功返回套接字句柄，失败返回INVALID_SOCKET
```

#### （2）client

```c
//Windows
int connect(SOCKET s, const struct sockaddr* name, int namelen);	//成功返回0,，失败返回SOCKET_ERROR
```

#### （3）Windows和Linux区别

* Linux中文件和套接字都用文件描述符描述。Windows中分别用文件句柄和套接字句柄描述。

* 关闭socket

  ```c
  //Linux
  sock.close();	//同文件关闭
  //Windows
  closesocket(sock)	//socket关闭函数
  ```

* Windows使用ws2_32.lib库。定义套接字前，需要初始化库。程序结束前，需将库归还OS，之后无法调用socket函数

  ```c
  #include<winsock2.h>
  int WSAStartup(WROD versionWinsock, WSADATA* lpWSAData);	//成功时返回0
  ......
  int WSACleanup();	//成功返回0，失败返回SOCKET_ERROR
  ```

  > versionWinsock——winsock的版本号，通过MAKEWORD函数方便生成版本号，如主版本1副版本2，MAKEWORD(1, 2)生成0x0201，高位为副版本号

  ```c
  int main(int argc, int argv[]){
      WSADATA wsaData;
      if(WSAStartup(MAKEWORD(2,2),&wsaData)!=0){
          Error_handling("WSAStartup error");
      }
      return 0;
  }
  ```

* 两平台函数名、参数名都相同，只是返回值类型使用不同，需关注。

  > Linux——返回int值，保存文件描述符。错误返回-1
  >
  > ```c
  > SOCKET soc = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
  > if(soc == -1){
  >  ErrorHandling();
  > }
  > ```
  >
  > Win——返回值结构体SOCKET，保存整数型套接字句柄值（本质也是int，为了扩展性定义为SOCKET）.错误返回INVALID_SOCKET
  >
  > ```c
  > SOCKET soc = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
  > if(soc == INVALID_SOCKET){
  >  ErrorHandling();
  > }
  > ```

---

## 4. 创建套接字

### （1）socket函数

```c
//创建socket，此时尚且未分为sock_serv或sock_clnt
//经过bind、listen后的转为sock_serv，经过accecpt的转为sock_clnt
#include<sys/socket.h>
int socket(int domain, int type ,int protocol);	//失败时：-1
```

> domain——协议族
>
> > PF_INET——IPv4
> >
> > PF_INET——IPv6
>
> type——数据传输方式（某个协议族中有多种数据传输方式）
>
> > SOCK_STREAM——面向连接、可靠、有序传输、流量控制、多次发送一次读取
> >
> > SOCK_DGRAM——无连接、不可靠、高速传输、一次发送对应一次读取
>
> protocol——指定具体协议（一般置0，若某协议族中同样数据传输方式的协议有多个，则需要指定具体是哪个协议）
>
> > IPPROTO_TCP
> >
> > IPPROTO_UDP

### （2）Linux建立TCP套接字

```c
/**
*tcp_client.c
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(char* message) {
	printf("%s\n", message);
}

int main(int argc, char* argv[])
{
	int sock;
	struct sockaddr_in serv_addr;
	char message[30];
	int str_len = 0;
	int idx = 0, read_len = 0;

	if (argc != 3) {
		printf("Use: %s<IP> <port>\n", argv[0]);	//若执行程序的命令行参数不是3，则打印格式："tcp_client <IP> <port>"
		exit(l);
	}

	sock = socket(PF_ INET, SOCK_STREAM, 9);
	if (sock == -1)
		error_handling("socket() error");

	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = inet_addr(argv[1]]);	//从命令行参数中取出IP地址
	serv_add.sin_port = htons(atoi(argv[2]));	//从命令行参数中取出端口
	if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {
		error_handling("connect error");
	}
	while (read_len = read(sock, &message[idx++], 1)) {
		if (read_len == -1) {
			error_handling("read error");
		}
		str_len += read_len;
	}
	printf("Message from server: %s \n", message);
	printf("function call count: %d \n", str_len);
	close(sock);
	return 0;
}
```

---

## 5. 绑定IP和端口号

### （1）sockaddr_in

```c
struct sockaddr_in{
    sa_family_t		sin_family;	//地址族IPv4/IPv6
    struct in_addr	sin_addr;	//32位IP地址
    uint16_t	    sin_port;	//16位端口号
    char	sin_zero[8];	//为了和sockaddr保持一致所设置的成员，必须全填充0
}
```

sin_addr是结构体变量，类型是`struct in_addr`。但in_addr声明为uint32_t，故直接将sin_addr当做32位整型变量即可。

**bind函数第二个参数实际需要的类型是sockaddr，因此需要将sockaddr_in类型变量强转为sockaddr类型**

```c
struct sockaddr{
    sa_family_t	sin_family;	//地址族
    char		sa_data[14];	//IP+port
}
```

sa_data中应该填充地址信息，剩余位填充0。但是直接操作十分麻烦，所以有了新的结构体sockaddr_in，通过设置和强转可生成符合要求的sockaddr类型变量。

### （2）网络字节序

CPU向**内存**中写入数据/解析内存中数据存在2种方式——小端序、大端序

> 如：0x1234，高字节是12，低字节是34。大端序存储于内存中时，在从低到高字节内存中分别存储的是12、34；在小端序中存储时为34、12

#### 小端序——先处理数据低字节

内存中从低字节到高字节，依次存储数据的低字节到高字节

#### 大端序——先处理数据高字节

内存中从低字节到高字节，依次存储数据的高字节到低字节

#### 将网络字节序统一为大端序

主机**发送数据**和**接收数据**，都是从内存中的低字节向高字节

> 大端序主机发送0x1234时，先发送12后发送34。小端序主机接收后，将12放到低字节内存，34放到高字节内存。但是，小端序主机，将12解析为数据中的低字节，34解析为数据中的高字节，所以解析出的数据最终会变为0x3412。

### （3）字节序转换函数

h——主机字节序，n——网络字节序，l表示4字节long，s表示2字节short

#### 头文件

```c
#include<arpa/inet.h>	//头文件
```

#### htonl——将4字节无符长整形数据从主机字节序转换为网络字节序

#### htons——2字节无符短整型

#### ntohl——将4字节数据从网络字节序转化为主机字节序

#### ntohs

* 理论上，大端序的主机不需要经过转换，但实际中Intel和AMD的CPU都是小端序，故都需要经过主机字节序到网络字节序的转换。

### （4）字符串型点分十进制IP地址和整型数据互转

### 头文件

```c++ 
#include<arpa/inet.h>	//头文件
```

点分十进制IP是字符串形式，需要函数将字符串形式的IP转换为32位整型数据才能绑定地址

#### <1>新型

#### inet_pton——点分十进制字符串转为二进制网络字节序IP

https://blog.csdn.net/zyy617532750/article/details/58595700

**IPv4、IPv6都适用**

```C
int inet_pton(int af_family, const char *str, void *addr);	//成功返回1，出错返回-1，af不是有效表达式返回0
```

> * family——AF_INET、AF_INET6（IPv6）



#### inet_ntop——二进制网络字节序IP转成点分十进制字符串IP

```c
const char* inet_ntop(int af_family， const void* addr, char* str, size_t len_str)	//成功返回str，失败返回NULL
```

> * addr——二进制数值IP
> * str存储字符IP
> * len_str=sizeof(str)

```c
inet_pton(AF_INET, argc[1], &clnt_addr.sin_addr);	

char  str[INET_ADDRSTRLEN];
char* ptr_str = inet_ntop(AF_INET, &clnt_addr.sin_addr, str, sizeof(str));
```

#### <2>



####  inet_aton——将点分十进制字符串IP转成网络字节序二进制存储在struct in_addr变量中

```c
int inet_aton(const char* str, struct in_addr* addr);	//成功返回true，失败返回false
```

> * 功能同inet_addr。该函数使用频率更高。
> * addr是sockaddr_in结构体中的成员，保存IP地址。该函数可自动将转换后的IP地址赋值给addr，所以需要该变量的地址。省去了手动给sockaddr_in变量赋值的过程。

```c
#include<arpa/inet.h>
int main(int argc, char** argv){
    sockaddr_in clnt_addr;
    
    clnt_addr.sin_family=PF_INET;
    clnt_addr.sin_port=htons(atoi(argv[2]));
    if(!inet_aton(argv[1], &clnt_addr.sin_addr)){
        error_handling("aton error..");
    }
}
```

#### inet_ntoa——将 二进制网络字节序转成点分十进制字符串IP

```c
char* inet_ntoa(struct in_addr addr);	//成功返回字符串的地址，失败返回-1
```

> * 将网络字节序的二进制IP转化为字符串点分十进制形式

#### inet_addr

```c
in_addr_t inet_addr(const char* str);	//成功时返回整型网络字节序IP，失败返回INADDR_NONE
```

> * 将字符串形式的点分十进制IP，转换成32位整型形式，且同时转换成网络字节序
> * 具有自动检测str是否是合法IP地址的功能
> * 只能转IPv4

#### <3>

#### atoi——字符串转整型

```c++
int atoi(const char* str);	//成功时返回整型，失败返回0
```

https://blog.csdn.net/p312011150/article/details/81273888

**头文件——<stdlib.h>**

> * **atoi()函数的功能：**将字符串转换成整型数；atoi()会扫描参数nptr字符串，跳过前面的空格字符，**直到遇上数字或正负号才开始做转换，而再遇到非数字或字符串时（'\0'）才结束转化**，并将结果返回（返回转换后的整型数）
>
>   ```c++
>   //辨析下面的代码
>   char buff[]={'2','4','5','+'};
>   int num = atoi(buff);
>   p num	//245
>         
>   int num_ = (int)(buff[0] - '0');
>   p num_   //2
>   ```

自己实现atoi函数：

```C
//C实现：
#include <ctype.h>
#include <stdio.h>
int atoi (char s[]);
int main(void )
{
	char s[100];
	gets(s);
	printf("integer=%d\n",atoi(s));
	return 0;
}
int atoi (char s[])
{
	int i,n,sign;
	for(i=0;isspace(s[i]);i++)	//跳过空白符;
	sign=(s[i]=='-')?-1:1;		//sign标记正负号
	if(s[i]=='+'||s[i]==' -')	//跳过符号
  		i++;
	for(n=0;isdigit(s[i]);i++)
       	n=10*n+(s[i]-'0');	//将数字字符转换成整形数字
	return sign *n;
}

```

```c
1    #include <iostream>
2    using namespace std;
3  
4    int str2int(const char *str)
5    {
6        int temp = 0;
7        const char *ptr = str;  //ptr保存str字符串开头
8  
9        if (*str == '-' || *str == '+')  //如果第一个字符是正负号，
10       {                      //则移到下一个字符
11           str++;
12       }
13       while(*str != 0)
14       {
15           if ((*str < '0') || (*str > '9'))  //如果当前字符不是数字
16           {                       //则退出循环
17               break;
18           }
19           temp = temp * 10 + (*str - '0'); //如果当前字符是数字则计算数值。数值增加一个低位，则原temp增大10倍并加上低位值
20           str++;      //移到下一个字符
21       }  
22       if (*ptr == '-')     //如果字符串是以“-”开头，则转换成其相反数
23       {
24           temp = -temp;
25       }
26 
27       return temp;
28   }
29 
30   int main()
31   {
32       int n = 0;  
33       char p[10] = "";
34 
35       cin.getline(p, 20);   //从终端获取一个字符串
36       n = str2int(p);      //把字符串转换成整型数
37      
38       cout << n << endl;
39 
40       return 0;
41   }
```



#### itoa——整型转字符串

```C
char* itoa (int value, char* str, int base );	//成功时返回指向str的指针，无错误返回
```

> value——待转整型数
>
> str——存储转换后的字符数组
>
> base——转换后的进制
>
> ```C
> //十进制转二进制
> #include<cstdlib>
> #include<cstdio>
> int main()
> {
> 	int num = 10;
> 	char str[100];
> 	int n = atoi(itoa(num, str, 2));	//先把num转换为二进制的字符串，再把该字符串转换为整数
> 	printf("%d\n",n);
> 	return 0;
> }
> ```
>
> 

### （5）绑定IP和端口

***memset函数要放在函数体中，不能放在函数体外，否则会报“此声明没有存储类或类型说明符”错误***

```c++
#include<arpa/inet.h>
struct sockaddr_in addr;
memset(&addr, 0, sizeof(addr));	//全部置零，为了将addr中sin_zero置零
char* ip="192.168.1.5";
char* port="40000";

addr.sin_family=AF_INET;
addr.sin_addr.s_addr=inet_addr(ip);	//或是inet_aton(ip, &addr.sin_addr);
addr.sin_addr.s_addr=htonl(INADDR_ANY);
addr.sin_port=htons(atoi(port));	//atoi将字符串转成整型
```

### （6）bind、accept和connect

server端通过调用Listen处于待建立连接状态，只有调用Listen后的client端才可以调用connect与server端建立连接，连接对应socket放入队列中。建立连接后，accept从队列**提取**一个连接并返回，随后对该连接进行操作。

若client先调用connect，则会向队列中添加连接，待server调用accept后就会立即从队列中提取一个连接。

若server先调用accept，若队列中有连接，就提取一个。若没有连接，就阻塞待队列中有连接后再提取。

```c++
bind(serv_sock, (struct sockaddr*) &serv_addr, sizeof(serv_addr));
accept(serv_sock, (struct sockaddr*)&clnt_addr,&clnt_addr_size);
connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
```



---

## 6. ***read、write、recv、send***

由于TCP传输数据无边界，即write的数据长度若不够一个报文段，则会等若干次write的数据后一起发送。若write的数据长度超出一个报文段，则会将数据分割为若干报文段，多次发送。

**所以应该在client端，用变量记下write进流的总字节数。用while+read按照字节为单位读取数据，read返回值为每次读取的字节数，待读取字节总数达到write的字节总数时，再将存储下的完整数据进行处理。**

### （1）数据类型与类型转换

> **数据类型——决定了数据在内存中所占的Bit，和解析方式**
>
> **强转——决定了被强转数据从低位开始截取的Bit位数**

> **char和int在内存中都是以二进制存储，char对应的二进制数按照十进制/d解析就是字符在ASCII中序号。如'a'对应97，'9'对应57**
>
> **char强转为int时，将8Bit数据拷贝到32Bit内存的低8Bit。打印int变量时显示的是char字符在ASCII中序号**
>
> **int强转char时，截取最低8Bit数据拷贝到另一内存的8Bit。打印char时是int的最低8Bit对应数字作为序号在ASCII中的字符**
>
> ```c++
>int a = 9;
> char ch = a;
> p ch	//9 '\t'
> p/c ch	//'\t'
> //用char变量去接int变量时，直接把9存到char中，实际我们想要的存的是'9'在ASCII中的序号，而现在我们存的是'\t'的序号9。
> ```

```C++
char ch1 = 'a';	
p/t ch1	//00100001
p ch1 //97
int i1 = ch1;
p/t i1	//00000000 00000000 00000000 00100001
p i1	//97
```

```c++
char ch = '9';
char ch_ = ch - '0';
p ch_	//9，在ASCII中对应字符'\t'
p/t ch_		//00001001
int i1 = (int)ch_
p i1	//9
p/t i1	//00000000 00000000 00000000 00001001
```

* **'0'~'9'转成int的方法**

  ```c++
  char ch = '9';
  int num = (int)(ch - '0');	//num=9
  int num_ = (int)ch - 0;		//num_=57 - 0
  ```

  

### （2）sizeof和strlen的区别

https://blog.csdn.net/xing2388117/article/details/79820796

* ***strlen遇'\0'停止且必须遇到'\0'才停止，且必须以char*作为参数，且该段内存必须以'\0'结尾。***

* strlen不要用来求非字符数组的字节数，因为数字不到结尾就会出现\0'。

* 数组名arr表示首元素地址，&arr表示整个数组的地址。

* ***strlen获取字符数组实际字节数size。sizeof获取字符数组开辟的空间capacity。***

* 静态字符数组求字节数用sizeof。**动态字符数组求字节数不能用sizeof，用strlen**

* write（用strlen）将**nbytes=字符数组的实际大小**。
* read（用sizeof）**nbytes=字符数组的capacity**。

```c
//hello world
//client
char msg[]="hello world";
write(sock_clnt, msg, sizeof(msg));
//server
char msg[BUFF_SIZE]
read(sock_listen, msg, BUFF_SIZE-1);	//最后用来输出的msg，留一个字节给msg末尾的'\0'
//read(sock_serv, msg, sizeof(msg));
printf("msg: %s\n",msg);
```

```c
//echo
//client 
char msg[BUFF_SIZE];
cin>>msg;
write(sock_clnt, msg, strlen(msg));	//写入msg实际字节数个字节
read(sock_clnt, msg, BUFF_SIZE-1);	//读取BUFF_SIZE-1个字节
msg[BUFF_SIZE]='\0';
cout<<msg<<endl;

//echo
//server
char msg[BUFF_SIZE];
while(nbytes=read(sock_listen, msg, BUFF_SIZE)!=0){	//读取BUFF_SIZE个字节
    write(sock_listen, msg, strlen(msg));	//写入msg中实际字节数个字节
}
```

```c
size_t strlen(const char *str)
```

> * str——字符串
> * 遇'\0'而止，返回字符串中字符个数。字符串结尾的'\0'不计入
> * **strlen函数求字符串长度的原理是：从起始地址开始按字节读取，读取到'\0'(就是0)停止，
>   int a[2]={2,3}; a的两个元素占8个字节：0x02 0x00 0x00 0x00 0x03 0x00 0x00 0x00
>   那么strlen(a)从0x02读起，到0x00就停止，于是返回长度1，如果你把a[0]赋值为257,那就会返回2,a[0]赋值为65793,那就会返回3, a[0]赋值为16843009，就会返回5**

```c
sizeof (data type)
```

> * sizeof是在编译的时候就将结果计算出来了是类型所占空间的字节数，所以以数组名做参数时计算的是整个数组的大小
>
>   strlen是在运行的时候才开始计算结果，这是计算的结果不再是类型所占内存的大小，数组名就退化为指针了
>
> * sizeof不能计算动态分配空间的大小
>
>   ![image-20210927140833164](D:/WorkSpace/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/TCP_IP/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/image-20210927140833164-16327229387291.png)

### （3）cin

https://blog.csdn.net/bravedence/article/details/77282039

* 头文件

  ```c++
  #include<iostream>
  ```
  
* cin>>

  连续输入，以回车作为不同变量的间隔

  ```c++
  cin>>a>>b>>c;
  ```

  从缓冲区读取数据时，只读字符，跳过中间的空格、tab、换行符，跳过的这些分隔符留在缓冲区

  要想不跳过分隔符，用cin>>noskipws>>val

* 读取一个字符

  ```C++
  char a,b;
  a=cin.get();
  cin.get(b);
  ```

  cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，[Linux](http://lib.csdn.net/base/linux)为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)

* Windows中用system("pause");但是该方式调用系统资源。

  Linux中，C++使用cin.get()，C使用getchar()
  
* 读取一行

  ```c++
  cin.getline(arr,1024,'\n');
  ```

### （4）memset和memcpy

***memset函数要放在函数体中，不能放在函数体外，否则会报“此声明没有存储类或类型说明符”错误***

```c++
#include<string.h>	//C
#include<cstring>	//C++
void *memcpy(void *str1, const void *str2, size_t n)	//从存储区 str2 复制 n 个字节到存储区 str1
```

> - **str1** -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
> - **str2** -- 指向要复制的数据源，类型强制转换为 void* 指针。
> - **n** -- 要被复制的字节数。
>
> * 该函数返回一个指向目标存储区 str1 的指针。

```c++
#include<string.h>	//C
#include<cstring>	//C++
void *memset(void *str, int c, size_t n)	//复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符
```

```c++
#include <stdio.h>  
#include <string.h>  
#define BUFFER_SIZE	10  
  
int main(int argc, char * argv[]) {  
    char buffer[BUFFER_SIZE] = {0};  
    int input1 = 0, input2 = 0, output1 = 0, output2 = 0;  
  
    printf("size of int: %d\n", sizeof(int));  
  
    printf("Please input two integers\n");  
    scanf("%d", &input1);  
    scanf("%d", &input2);  
    printf("The input integers are : %d %d\n", input1, input2);  
  
    memcpy(buffer, &input1, sizeof(int));  
    memcpy(buffer + sizeof(int), &input2, sizeof(int));  
  
    printf("Buffer:\n");  
    for (int i = 0; i < BUFFER_SIZE; ++i) {  
        printf("0x%02x ", buffer[i]);  
    }  
    printf("\n");  
  
    memcpy(&output1, buffer, sizeof(int));  
    memcpy(&output2, buffer + sizeof(int), sizeof(int));  
  
    printf("The output integers retrieved from buffer: %d %d\n", output1, output2);  
  
    return 0;  
}  
```

```c++
size of int: 4  
Please input two integers  
100000  
200000  
The input integers are : 100000 200000  
Buffer:  
0xffffffa0 0xffffff86 0x01 0x00 0x40 0x0d 0x03 0x00 0x00 0x00  
The output integers retrieved from buffer: 100000 200000  
  
size of int: 4  
Please input two integers  
200000  
100000  
The input integers are : 200000 100000  
Buffer:  
0x40 0x0d 0x03 0x00 0xffffffa0 0xffffff86 0x01 0x00 0x00 0x00  
The output integers retrieved from buffer: 200000 100000  
  
size of int: 4  
Please input two integers  
0  
2147483647  
The input integers are : 0 2147483647            (2 ^ 31 - 1)  
Buffer:  
0x00 0x00 0x00 0x00 0xffffffff 0xffffffff 0xffffffff 0x7f 0x00 0x00  
The output integers retrieved from buffer: 0 2147483647  
```



### （5）write

write时将数据写入输出缓冲区，随后由内核通过TCP等协议将输出缓冲区中数据发送到对端的输入缓冲区

write并不是数据发送到对端后才返回值，而是将数据写入到输出缓冲区后就返回

```c++
#include <unistd.h>
ssize_t write (int fd, const void* buf, size_t count);
```

> * write()会把参数buf所指的内存写入**count个字节**到参数fd所指的文件内。
> * 返回值——如果顺利write()会返回实际写入的字节数（len）。当有错误发生时则返回-1，错误代码存入全局变量errno中。



### （6）read

read从输入缓冲区中读取数据，数据如何通过网络环境从对端到达本地的输入缓冲区是由内核通过TCP等协议控制的

```c++
#include <unistd.h>
ssize_t read(int fd, void * buf, size_t count);
```

> * count——最多读取count个字节
> * 返回值——顺利 read()会返回实际读到的字节数, 最好能将返回值与参数count 作比较。当有错误发生时则返回-1, 错误代码存入errno 中, 而文件读写位置则无法预期

### （7）char和int强转时的底层发生了什么

https://www.cnblogs.com/al-fajr/p/11615413.html

https://www.jianshu.com/p/309bf4421638

***指针——直击本质：存储一块连续内存区域的首地址的变量***

**内存实质上是字节数组，所谓类型是程序中规定的读取内存的方式**

**变量的类型不同实际上是读取内存的长度不同，是从不同的角度看内存内的数据。变量=内存地址+数据。指针变量=内存地址+偏移。**

**对指针类型的强转，实际上是将内存使用的位数改变了**

```c++
int a;
int* p1 = &a;	//p1指向32位连续内存
*p1 = 1;	//00000000 00000000 00000000 00000001
int* p2 = (char*)&a;	//p2指向8位连续内存
*p2 = 1;	//00000001
```

**数组中第i个字节的首地址&buff[ i - 1 ]**

**&buff[ i ]表明buff中已有i个字节，&buff[ i ]是第i + 1个字节的首地址**

```c++
char buff[BUF_SIZE];
buff[len];
```

> 首先，要知道一件事情：你在代码里写的事情，计算机未必会干。
>
> 比如：
>
> ```text
> char var = 'a';
> var = (int) var;
> ```
>
> 没准人家编译器看你没有产生实际效用，就直接给砍了。
>
> 更严格来讲，你应当写：
>
> ```text
> char var1 = 'a';
> int var2 = (int) var1;
> ```
>
> 这就有点实际意义了。
>
> > 一直对基本类型的cast疑惑不解
>
> C的基本类型，大都能对应到CPU能处理的标准数字类型。char基本都是一个8位有符号整数，最高位是符号位。int是不低于16位的有符号整数（所有的常见平台上都是32位），最高位是符号位。
>
> 那么进行这种转换，基本上就是编译器把这件事情翻译成一个或者几个CPU指令，大概是：
>
> - 从地址var1读内容到寄存器；
> - 执行8位到32位的有符号整数转换；
> - 将结果从寄存器写到地址var2，写32位。
>
> 对于ASCII，a的数值是97，用八位的二进制数表示，就是01100001。把它转换到int，实际上就是在求一个32位有符号的值，数值意义和01100001要相等。编译器会把你这个表达式翻译成对应的CPU操作。结果是00000000 00000000 00000000 01100001。
>
> 看起来好像除了填上一堆零，啥都没干？
>
> 实际上填零是重要操作，因为内存空间可以是脏的：在你给丫赋值之前，丫可能还带着上次计算完之后的垃圾。
>
> 而且，如果是负数，就会很不一样。比如：
>
> ```text
> char var1 = -1;
> int var2 = (int) var1;
> ```
>
> 由于现代计算机几乎全都用补码来表示负数，于是负一的8位二进制表示，是11111111；而32位表示，则是11111111 11111111 11111111 11111111。不难看到，对于有符号数的长度转换，并不总是填零的。
>
> 所以CPU在这里面，还是需要做一些微小的工作。
>
> ======================
>
> 补充运行时类型的问题：
>
> C这种语言，要的就是运行时不带类型记号的裸奔快感。比如对于类似这样的源代码：
>
> ```text
> int a = some_procedure();
> int b = some_other_procedure();
> int c = a + b;
> ```
>
> 最后的那个相加，在不优化的情况下，通常会产生类似这样的几个指令：
>
> - 从地址a取32位数据到寄存器1；
> - 从地址b取32位数据到寄存器2；
> - 执行32位整形加法；
> - 将32位数据写到地址c；
>
> 可以看到，**这里面没有类型。对数据的操作方式就是类型。（取数据的位数）**

### （8）send

https://www.cnblogs.com/ellisonzhang/p/10412021.html

![image-20211012151257433](https://i.loli.net/2021/10/12/7suYTyHDxAcWG5I.png)

 

### （9）recv

![image-20211012151209115](https://i.loli.net/2021/10/12/8FLvI5lgmdJCscQ.png)

在进行TCP协议传输的时候，要注意数据流传输的特点，recv和send不一定是一一对应的（一般情况下是一一对应），也就是说并不是send一次，就一定recv一次就接收完，有可能send一次，recv多次才接收完，也可能send多次，一次recv就接收完了。TCP协议会保证数据的有序完整的传输，但是如何去正确完整的处理每一条信息，是程序员的事情。
例如：服务器在循环recv，recv的缓冲区大小为100byte，客户端在循环send，每次send 6byte数据，则recv每次收到的数据可能为6byte，12byte，18byte，这是随机的，编程的时候注意正确的处理。

---

## 7. socket缓冲区

![图片](https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjXicIIHoCtx2KrEJLHASA3CRkD5t7X0mYlOm3XSXpnibbjiaqAD7ZRMmew/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)目录

代码执行send成功后，数据就发出去了吗？

回答这个问题之前，需要了解什么是**Socket 缓冲区**。

### 什么是 socket 缓冲区

编程的时候，如果要跟某个IP建立连接，我们需要调用操作系统提供的 `socket API`。

**socket** 在操作系统层面，可以理解为一个**文件**。

我们可以对这个文件进行一些**方法操作**。

用`listen`方法，可以让程序作为服务器**监听**其他客户端的连接。

用`connect`，可以作为客户端**连接**服务器。

用`send`或`write`可以**发送**数据，`recv`或`read`可以**接收**数据。

在建立好连接之后，这个 **socket** 文件就像是远端机器的 **"代理人"** 一样。比如，如果我们想给远端服务发点什么东西，那就只需要对这个文件执行写操作就行了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjvRd2M0FiaaT9nWzLibKUflPASdGv9ZLtxEQlBu8zKrUmPbibnC6CGFcVA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)socket_api

那写到了这个文件之后，剩下的发送工作自然就是由操作系统**内核**来完成了。

既然是写给操作系统，那操作系统就需要**提供一个地方给用户写**。同理，接收消息也是一样。

这个地方就是 **socket 缓冲区**。

用户**发送**消息的时候写给 send buffer（发送缓冲区）

用户**接收**消息的时候写给 recv buffer（接收缓冲区）

也就是说**一个socket ，会带有两个缓冲区**，一个用于发送，一个用于接收。因为这是个先进先出的结构，有时候也叫它们**发送、接收队列**。

![图片](https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjicVh0e15ib4rx1N0V9ic5eWtXKp8GZAefOYONT4KKfUhcAkqJvph7CNfQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)一个socket有两个缓冲区

#### 怎么观察 socket 缓冲区

如果想要查看 socket 缓冲区，可以在linux环境下执行 `netstat -nt` 命令。

```
# netstat -nt
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0     60 172.22.66.69:22         122.14.220.252:59889    ESTABLISHED
```

这上面表明了，这里有一个协议（Proto）类型为 TCP 的连接，同时还有本地（Local Address）和远端（Foreign Address）的IP信息，状态（State）是已连接。

还有**Send-Q 是发送缓冲区**，下面的数字60是指，当前还有60 Byte在发送缓冲区中未发送。而 **Recv-Q 代表接收缓冲区**， 此时是空的，数据都被应用进程接收干净了。

### TCP部分

【动图缓冲区的收发流程，TCP执行发收的流程】

我们在使用TCP建立连接之后，一般会使用 send 发送数据。

```
int main(int argc, char *argv[])
{
    // 创建socket
    sockfd=socket(AF_INET,SOCK_STREAM, 0))

    // 建立连接  
    connect(sockfd, 服务器ip信息, sizeof(server))  

    // 执行 send 发送消息
    send(sockfd,str,sizeof(str),0))  

    // 关闭 socket
    close(sockfd);

    return 0;
}
```

上面是一段伪代码，仅用于展示大概逻辑，我们在建立好连接后，一般会在代码中执行 `send` 方法。那么此时，消息就会被立刻发到对端机器吗？

### 执行 send 发送的字节，会立马发送吗？

答案是不确定！执行 send 之后，数据只是拷贝到了socket 缓冲区。至 什么时候会发数据，发多少数据，全听操作系统安排。

![图片](https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjqxb2RZpP3PEu9PpjaALP2ic37KzVtytibmQ9uRHRxdaseKHHkxxtWDLA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)tcp_sendmsg 逻辑

在用户进程中，程序通过操作 socket 会从用户态进入内核态，而 send方法会将数据一路传到传输层。在识别到是 TCP协议后，会调用 tcp_sendmsg 方法。

```
// net/ipv4/tcp.c
// 以下省略了大量逻辑
int tcp_sendmsg()
{  
  // 如果还有可以放数据的空间
  if (skb_availroom(skb) > 0) {
    // 尝试拷贝待发送数据到发送缓冲区
    err = skb_add_data_nocache(sk, skb, from, copy);
  }  
  // 下面是尝试发送的逻辑代码,先省略     
}
```

在 tcp_sendmsg 中， 核心工作就是将待发送的数据组织按照先后顺序放入到发送缓冲区中， 然后根据实际情况（比如拥塞窗口等）判断是否要发数据。如果不发送数据，那么此时直接返回。

### 如果缓冲区满了会怎么办

前面提到的情况里是，发送缓冲区有足够的空间，可以用于拷贝待发送数据。

#### 如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？

这里分两种情况。

首先，socket在创建的时候，是可以设置是**阻塞**的还是**非阻塞**的。

```
int s = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);
```

比如通过上面的代码，就可以将 `socket` 设置为**非阻塞** （`SOCK_NONBLOCK`）。

当发送缓冲区**满了**，如果还向socket执行send

- 如果此时 socket 是阻塞的，那么程序会在那**干等、死等**，直到释放出新的缓存空间，就继续把数据拷进去，然后**返回**。

![图片](https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjeg5UOCtVEU0TC9eNeSybzlfmKzZDmo3sBBOsOt8ibydIEBQMt3W4QCw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)send阻塞

- 如果此时 socket 是非阻塞的，程序就会**立刻返回**一个 `EAGAIN` 错误信息，意思是  `Try again` , 现在缓冲区满了，你也别等了，待会再试一次。

![图片](https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjWL1ptVibTnKOsMc7lCQEgWLUhZX3VBzMYHPPvmcrZyAt1RheRhcZCFQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)send非阻塞

我们可以简单看下源码是怎么实现的。还是回到刚才的 `tcp_sendmsg` 发送方法中。

```
int tcp_sendmsg()
{  
  if (skb_availroom(skb) > 0) {
    // ..如果有足够缓冲区就执行balabla
  } else {
    // 如果发送缓冲区没空间了，那就等到有空间，至于等的方式，分阻塞和非阻塞
    if ((err = sk_stream_wait_memory(sk, &timeo)) != 0)
        goto do_error;
  }   
}        
```

里面提到的  `sk_stream_wait_memory` 会根据`socket`是否阻塞来决定是一直等等一会就返回。

```
int sk_stream_wait_memory(struct sock *sk, long *timeo_p)
{
    while (1) {
    // 非阻塞模式时，会等到超时返回 EAGAIN
        if (等待超时))
            return -EAGAIN;     
     // 阻塞等待时，会等到发送缓冲区有足够的空间了，才跳出
        if (sk_stream_memory_free(sk) && !vm_wait)
            break;
    }
    return err;
}
```

#### 如果接收缓冲区为空，执行 recv 会怎么样？

接收缓冲区也是类似的情况。

当接收缓冲区**为空**，如果还向socket执行 recv

- 如果此时 socket 是阻塞的，那么程序会在那**干等**，直到接收缓冲区有数据，就会把数据从接收缓冲区拷贝到用户缓冲区，然后**返回**。

![图片](https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjSJukYkMGeUviaGDLIaCk6oZ8J3VqPcu61Cq2tq6xiaWxWgtbQwrm7XDg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)recv阻塞

- 如果此时 socket 是非阻塞的，程序就会**立刻返回**一个 `EAGAIN` 错误信息。

![图片](https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjNLGjIFwxJuPicnESic7QGicYc7y4Zib4YANHNl7icNzbtyLK9Ja6ElydPwA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)recv非阻塞

下面用一张图汇总一下，方便大家保存面试的时候用哈哈哈。

![图片](https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsj9hSlrmT2jGibWZW7blcOgJxZQX7BznAAGxU6AX6nn6vDto9rsDvLpEA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)socket读写缓冲区满了的情况汇总

### 如果socket缓冲区还有数据，执行close了，会怎么样？

首先我们要知道，**一般正常情况下，发送缓冲区和接收缓冲区 都应该是空的。**

如果发送、接收缓冲区长时间非空，说明有数据堆积，这往往是由于一些网络问题或用户应用层问题，导致数据没有正常处理。

那么正常情况下，如果 `socket` 缓冲区**为空**，执行 `close`。就会触发四次挥手。

![图片](https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjSfT17HEmqQ3YnuSic8aL9XJhGOEgdXkB14txCYzPSqjR8NDu0up6nRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)TCP四次挥手

这个也是面试老八股文内容了，**这里我们只需要关注第一次挥手，发的是 `FIN` 就够了**。



#### 如果接收缓冲区有数据时，执行close了，会怎么样？

`socket close` 时，主要的逻辑在 `tcp_close()` 里实现。

先说结论，关闭过程主要有两种情况：

- 如果接收缓冲区还有数据未读，会先把接收缓冲区的数据清空，然后给对端发一个RST。
- 如果接收缓冲区是空的，那么就调用 `tcp_send_fin()` 开始进行四次挥手过程的第一次挥手。

```
void tcp_close(struct sock *sk, long timeout)
{
  // 如果接收缓冲区有数据，那么清空数据
    while ((skb = __skb_dequeue(&sk->sk_receive_queue)) != NULL) {
        u32 len = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq -
              tcp_hdr(skb)->fin;
        data_was_unread += len;
        __kfree_skb(skb);
    }

   if (data_was_unread) {
    // 如果接收缓冲区的数据被清空了，发 RST
        tcp_send_active_reset(sk, sk->sk_allocation);
     } else if (tcp_close_state(sk)) {
    // 正常四次挥手， 发 FIN
        tcp_send_fin(sk);
    }
    // 等待关闭
    sk_stream_wait_close(sk, timeout);
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjjP4WDVfnF2bmf32kZ6icQHfOa8OibmS5MZG9TFMQ96GNltYibOFDGFTkg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)recvbuf非空

#### 如果发送缓冲区有数据时，执行close了，会怎么样？

以前以为，这种情况下，内核会把发送缓冲区数据清空，然后四次挥手。

但是发现源码**并不是这样的**。

```
void tcp_send_fin(struct sock *sk)
{
  // 获得发送缓冲区的最后一块数据
    struct sk_buff *skb, *tskb = tcp_write_queue_tail(sk);
    struct tcp_sock *tp = tcp_sk(sk);

  // 如果发送缓冲区还有数据
    if (tskb && (tcp_send_head(sk) || sk_under_memory_pressure(sk))) {
        TCP_SKB_CB(tskb)->tcp_flags |= TCPHDR_FIN; // 把最后一块数据值为 FIN 
        TCP_SKB_CB(tskb)->end_seq++;
        tp->write_seq++;
    }  else {
    // 发送缓冲区没有数据，就造一个FIN包
  }
  // 发送数据
    __tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);
}
```

此时，还有些数据没发出去，内核会把发送缓冲区最后一个数据块拿出来。然后置为 FIN。

`socket` 缓冲区是个**先进先出**的队列，这种情况是指内核会等待TCP层安静把发送缓冲区数据都发完，最后再执行 四次挥手的第一次挥手（FIN包）。

有一点需要注意的是，只有在**接收缓冲区为空的前提下**，我们才有可能走到 `tcp_send_fin()` 。而只有在进入了这个方法之后，我们才有可能考虑发送缓冲区是否为空的场景。

![图片](https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjWnK0M8ibXAAxOl5mudeZcVDYZU0icOfn4WcCME5iaHBdXib3oqZH7kyic1g/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)sendbuf非空

## UDP部分

### UDP也有缓冲区吗

说完TCP了，我们聊聊UDP。这对好基友，同时都是传输层里的重要协议。既然前面提到TCP有发送、接收缓冲区，那UDP有吗？

以前我以为。

> "每个UDP socket都有一个接收缓冲区，没有发送缓冲区，从概念上来说就是只要有数据就发，不管对方是否可以正确接收，所以不缓冲，不需要发送缓冲区。"

后来我发现我错了。

UDP socket 也是 socket，一个socket 就是会有收和发两个缓冲区。跟用什么协议关系不大。

有没有是一回事，用不用又是一回事。

### UDP不用发送缓冲区？

事实上，UDP不仅有发送缓冲区，也用发送缓冲区。

一般正常情况下，会把数据直接拷到发送缓冲区后直接发送。

还有一种情况，是在发送数据的时候，设置一个 `MSG_MORE` 的标记。

```
ssize_t send(int sock, const void *buf, size_t len, int flags); // flag 置为 MSG_MORE
```

大概的意思是告诉内核，待会还有其他**更多消息**要一起发，先别着急发出去。此时内核就会把这份数据先用**发送缓冲区**缓存起来，待会应用层说ok了，再一起发。

我们可以看下源码。

```
int udp_sendmsg()
{
    // corkreq 为 true 表示是 MSG_MORE 的方式，仅仅组织报文，不发送；
    int corkreq = up->corkflag || msg->msg_flags&MSG_MORE；

    //  将要发送的数据，按照MTU大小分割，每个片段一个skb；并且这些
    //  skb会放入到套接字的发送缓冲区中；该函数只是组织数据包，并不执行发送动作。
    err = ip_append_data(sk, fl4, getfrag, msg->msg_iov, ulen,
                 sizeof(struct udphdr), &ipc, &rt,
                 corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);

    // 没有启用 MSG_MORE 特性，那么直接将发送队列中的数据发送给IP。 
    if (!corkreq)
        err = udp_push_pending_frames(sk);

}
```

因此，不管是不是 `MSG_MORE`， IP都会先把数据放到发送队列中，然后根据实际情况再考虑是不是立刻发送。

而我们大部分情况下，都不会用  `MSG_MORE`，也就是来一个数据包就直接发一个数据包。从这个行为上来说，**虽然UDP用上了发送缓冲区，但实际上并没有起到"缓冲"的作用。**



---

## 8. TCP总结

### （1）server、client中的几个socket和sockaddr_in

* server

  > * sock_listen——***需要手动bind服务器的IP和监听端口（addr_serv）***，用于**监听**客户端连接请求的，作用是建立连接
  > * sock_clnt——初始化空socket，用于accept从队列中提取一个客户端连接socket后，用于**将提取出的客户端socket赋值给它**，后用于**读写数据**。可有多个，用于给多个客户端的连接赋值，用于给不同的客户端读写数据

* client

  > * addr_serv——client想要连接的服务端的IP和端口，需要手动赋值
  > * sock_clnt——***不需要手动bind客户端的IP和端口，connect addr_serv后自动分配，在server中由accept提取出来。***连接服务端的socket，用于**读写数据**。sock_clnt通过`connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr))`连接服务端。

#### Q：client、server中的sock_clnt是相同的吗？



---

## 9. UDP

```c++
//client
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define BUF_SIZE 30
void error_handling(char *message);

int main(int argc, char *argv[])
{
	int sock;
	char message[BUF_SIZE];
	int str_len;
	socklen_t adr_sz;
	
	struct sockaddr_in serv_adr;
	if(argc!=3){
		printf("Usage : %s <IP> <port>\n", argv[0]);
		exit(1);
	}
	
	sock=socket(PF_INET, SOCK_DGRAM, 0);   
	if(sock==-1)
		error_handling("socket() error");
	
	memset(&serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family=AF_INET;
	serv_adr.sin_addr.s_addr=inet_addr(argv[1]);
	serv_adr.sin_port=htons(atoi(argv[2]));
	
	while(1)
	{
		fputs("Insert message(q to quit): ", stdout);
		fgets(message, sizeof(message), stdin);     
		if(!strcmp(message,"q\n") || !strcmp(message,"Q\n"))	
			break;
		
		sendto(sock, message, strlen(message), 0, (struct sockaddr*)&serv_adr, sizeof(serv_adr));	//sock没有绑定IP和端口，在sendto之前由																							  //系统自动分配，见P108
		adr_sz=sizeof(serv_adr);
		str_len=recvfrom(sock, message, BUF_SIZE, 0, (struct sockaddr*)&serv_adr, &adr_sz);

		message[str_len]=0;
		printf("Message from server: %s", message);
	}	
	close(sock);
	return 0;
}

void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```

```c++
//server
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define BUF_SIZE 30
void error_handling(char *message);

int main(int argc, char *argv[])
{
	int serv_sock;
	char message[BUF_SIZE];
	int str_len;
	socklen_t clnt_adr_sz;
	
	struct sockaddr_in serv_adr, clnt_adr;
	if(argc!=2){
		printf("Usage : %s <port>\n", argv[0]);
		exit(1);
	}
	
	serv_sock=socket(PF_INET, SOCK_DGRAM, 0);
	if(serv_sock==-1)
		error_handling("UDP socket creation error");
	
	memset(&serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family=AF_INET;
	serv_adr.sin_addr.s_addr=htonl(INADDR_ANY);
	serv_adr.sin_port=htons(atoi(argv[1]));
	
	if(bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr))==-1)
		error_handling("bind() error");

	while(1) 
	{
		clnt_adr_sz=sizeof(clnt_adr);
		str_len=recvfrom(serv_sock, message, BUF_SIZE, 0, 
								(struct sockaddr*)&clnt_adr, &clnt_adr_sz);	//client连接server后，clnt_adr将从client发送过来
		sendto(serv_sock, message, str_len, 0, 
								(struct sockaddr*)&clnt_adr, clnt_adr_sz);
	}	
	close(serv_sock);
	return 0;
}

void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}

```



### （1）和TCP的对比

* TCP速度慢于UDP的原因主要是2点——TCP连接的建立、断开过程，TCP多种保证可靠性的协议
* 当需求多次连接传输少量数据时，UDP更快

* TCP需要建立端到端的连接，所以一对socket对应一个连接。UDP没有连接，所以

* TCP的socket在建立连接后，在close之前，地址都不会改变。而UDP的目标地址是变化的，所以每次传输数据时都要添加目标地址

### （2）IO函数

server的addr_serv需要赋值，socket需要手动bind IP和端口

client的addr_clnt不需要赋值，socket不需手动bind addr_clnt，但是addr_serv需要手动bind

#### sendto

```c++
#include <sys/socket.h>
ssize_t sendto(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *to, socklen_t to_len);
```

> * sockfd——发送数据端的socket
> * buff——内存
> * nbytes——待发送的数据的字节数
> * flags——
> * to——目标地址
> * tolen——sizeof(to)，注意是***数值***
> * 返回值——成功则返回实际传送出去的字符数，失败返回－1，错误码存于errno 中



#### recvfrom

```c++
#include <sys/socket.h>
ssize-t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr* from, socklen_t *from_len);
```

> * sockfd——接收数据端的socket
> * nbytes——可接受的最多字节数
> * from——目标地址

#### UDP中sendto和recvfrom的次数必须一一对应

UDP有数据边界，一次发送的数据不论长短都封装为一个数据报

一端sendto了多少次，另一端也必须要recvfrom多少次。即使，一端一次性sendto了n次数据，数据全部到达了另一端，另一端也需要recvfrom n次

而TCP则可用一次read读取若干次发送过来的数据

### （3）connected UDP

![image-20211008115732011](D:/WorkSpace/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/TCP_IP/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/ZCfSsAit4LGrz56.png)

client在sendto数据之前，用connect将目标地址固定为addr_serv，提高效率。随后每次send时不需要指定地址，可以不用sendto，改用write

除了send要和write个数相同以外，其他同TCP

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define BUF_SIZE 30
void error_handling(char *message);

int main(int argc, char *argv[])
{
	int sock;
	char message[BUF_SIZE];
	int str_len;
	socklen_t adr_sz;
	
	struct sockaddr_in serv_adr, from_adr;
	if(argc!=3){
		printf("Usage : %s <IP> <port>\n", argv[0]);
		exit(1);
	}
	
	sock=socket(PF_INET, SOCK_DGRAM, 0);   
	if(sock==-1)
		error_handling("socket() error");
	
	memset(&serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family=AF_INET;
	serv_adr.sin_addr.s_addr=inet_addr(argv[1]);
	serv_adr.sin_port=htons(atoi(argv[2]));
	
	connect(sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr));

	while(1)
	{
		fputs("Insert message(q to quit): ", stdout);
		fgets(message, sizeof(message), stdin);     
		if(!strcmp(message,"q\n") || !strcmp(message,"Q\n"))	
			break;
		/*
		sendto(sock, message, strlen(message), 0, 
					(struct sockaddr*)&serv_adr, sizeof(serv_adr));
		*/
		write(sock, message, strlen(message));

		/*
		adr_sz=sizeof(from_adr);
		str_len=recvfrom(sock, message, BUF_SIZE, 0, 
					(struct sockaddr*)&from_adr, &adr_sz);
		*/
		str_len=read(sock, message, sizeof(message)-1);

		message[str_len]=0;
		printf("Message from server: %s", message);
	}	
	close(sock);
	return 0;
}

void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```



---

## 10. TCP连接半关闭

### （1）C风格文件读写函数

#### fopen

打开文件，返回流

```C++
#include <stdio.h>
FILE *fopen(const char *filename, const char *mode);
```

“文件指针名”必须是被声明为FILE 类型的指针变量；

```c++
FILE* fstream = fopen("a.txt","t+");	//允许对文本文件读写
```

“文件名”是被打开文件的文件名，类型是C风格字符串；

“使用文件方式”是指文件的类型和操作要求。

> r(read): 只读，文件必须存在
>
> w(write): 只写，创建空文件，若同名文件已存在则原文件被删除
>
> a(append): 追加，若文件不存在则创建
>
> t(text): 文本文件，可省略不写
>
> b(binary): [二进制文件](https://baike.baidu.com/item/二进制文件)
>
> +: 读和写
>
> 返回值——该函数返回一个 FILE 指针。否则返回 NULL，且设置全局变量 errno 来标识错误。

#### fread

从输入流中读取数据到内存buf中

```c++
#include <stdio.h>
size_t fread(void *buf, size_t size, size_t nmemb, FILE *fstream)
```

> * **buf**——一块内存的地址，有nmemb个元素，每个元素的长度为size（字节）
> * **size**——内存块中元素的长度（B为单位）
> * **nmemb**——内存块中元素的个数
> * **fstream**——文件指针，指定了一个输入流（[详见C语言基于流式文件和IO文件的操作](https://blog.csdn.net/qq_15821725/article/details/78929344)）
> * **返回值**——成功读取的***元素总数***会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个**错误**或者***到达了文件末尾（文件实际大小小于nmemb）***

```c++
FILE* fp = fopen("server.cpp","rb");
char buf[BUF_SIZE];
fread(buf, 1, BUF_SIZE, fp);	//将server.cpp文件以二进制流读取至buf中
```



#### fwrite

将内存buf中的数据写入到输出流中

```c++
size_t fwrite(const void *buf, size_t size, size_t nmemb, FILE *stream)
```

> - **buf——**这是指向要被写入的元素数组的指针。
> - **size——**这是要被写入的每个元素的大小，以字节为单位。
> - **返回值——**如果成功，该函数返回一个 size_t 对象，表示**实际写入输出流中元素的总数**，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误

#### fseek

#### fclose

关闭流 stream，***刷新所有的缓冲区。在刷新缓冲区之前，所有读写的数据都存放于缓冲区，调用fclose后才写入硬盘***

```c++
#include <stdio.h>
int fclose(FILE *stream);
```

> 返回值——成功关闭，则该方法返回零。如果失败，则返回 EOF



### （2）为什么需要半关闭

close函数将会完全关闭连接，一旦关闭，在当前端所有读写函数都会无法使用，也就无法再收发数据。

因此，当某一端在发送完数据需要断开连接后，若还需要接收对端的数据，就需要只“关闭一半的连接”，使得断开连接后还能收或发数据。

***半关闭函数——shutdown***

发送数据方调用close或shutdown都会向接收端发送EOF，从而接收端会知道发送端的数据发送已完成。

**情景：**服务端将本地文件以二进制形式发送到客户端，发送完毕后，服务端断开连接。断开连接后，客户端接收到EOF后需要向服务端发送一个“data has been received!!”

**解决：**为了实现上述情景，需要服务端断开连接后虽然不再发送数据，但是还要能接收数据。所以半关闭shutdown(sock_clnt, SHUT_WR)。

### （3）shutdown

```c++
#include<sys/socket.h>
shutdown(int sock, int mode);
```

> * mode——断开方式
>
>   > SHUT_RD——只断开读连接
>   >
>   > SHUT_WR——只断开写连接
>   >
>   > SHUT_RDWR——同时断开读写连接，相当于同时调用SHUT_RD和SHUT_WR
>
> * 返回值——成功返回0；失败返回-1。

### （4）实例

```c++
//client.cpp
#include<iostream>
#include<cstring>
#include<sys/socket.h>
#include<arpa/inet.h>
#include<unistd.h>
using namespace std;
#define BUF_SIZE 100

int main(int argc, char** argv){
        char buf[BUF_SIZE];
        int sock_clnt;
        struct sockaddr_in addr_serv;

        sock_clnt =socket(PF_INET, SOCK_STREAM, 0);
        addr_serv.sin_family = AF_INET;
        addr_serv.sin_addr.s_addr = inet_addr(argv[1]);
        addr_serv.sin_port = htons(atoi(argv[2]));
        
        connect(sock_clnt, (struct sockaddr*)&addr_serv, sizeof(addr_serv));
        
        FILE* fstream = fopen("recv.txt","wt"); 
        int len = 0;
        
                len = recv(sock_clnt, buf, BUF_SIZE, 0);
                if(len!=0){
                        fwrite(buf, 1, len, fstream);
                }
        cout<<"file has been received!!"<<endl;

        char msg[] = "thank you!";
        int len_send = send(sock_clnt, msg, strlen(msg), 0);
        if(len_send == -1){
                cout<<"thank you send error.."<<endl;
        }else{
                cout<<"len_send="<<len_send<<endl;
        }

        fclose(fstream);
        close(sock_clnt);
        return 0;
}
```

```c++
//server.cpp
#include<iostream>
#include<cstring>
#include<sys/socket.h>
#include<arpa/inet.h>
#include<unistd.h>
using namespace std;
#define BUF_SIZE 100


int main(int argc, char** argv){
        char buf[BUF_SIZE];
        int sock_serv;
        struct sockaddr_in addr_serv;
        memset(&addr_serv, 0, sizeof(addr_serv));
        sock_serv = socket(PF_INET, SOCK_STREAM, 0);
        addr_serv.sin_family = AF_INET;
        addr_serv.sin_addr.s_addr = htonl(INADDR_ANY);
        addr_serv.sin_port = htons(atoi(argv[1]));

        bind(sock_serv, (struct sockaddr*)&addr_serv, sizeof(addr_serv));

        listen(sock_serv, 10);

        int sock_clnt;
        struct sockaddr_in addr_clnt;
        int addr_clnt_sz = sizeof(addr_clnt);

        sock_clnt = accept(sock_serv, (struct sockaddr*)&addr_clnt, (socklen_t*)&addr_clnt_sz);
        if(sock_clnt == -1){
                cout<<"connect error.."<<endl;
        }

        FILE* fstream = fopen("./test.txt", "rt");
        int len_fp = 0;
        while(1){
                len_fp = fread(buf, 1, BUF_SIZE, fstream);
                if(len_fp < BUF_SIZE){
                        send(sock_clnt, &buf, len_fp, 0);
                        break;
                }else if(len_fp == BUF_SIZE){
                        send(sock_clnt, &buf, BUF_SIZE, 0);
                }
        }

        shutdown(sock_clnt, SHUT_WR);
        memset(buf, 0, sizeof(buf));
        int len_recv = recv(sock_clnt, buf, BUF_SIZE, 0);
        cout<<"meg from client:"<<buf<<endl;

        fclose(fstream);
        close(sock_clnt);
        return 0;
}
```

---

## 11. DNS解析

### （1）gethostbyname——由域名获取域信息

```c++
#include<netdb.h>
struct hostent* gethostbyname(const char* host);
```

> **返回值**——失败时返回NULL
>
> **host**——主机域名
>
> **hostent**——存储域相关信息的结构体
>
> ```c++
> struct hostent{
>     char* h_name;		//官方域名
>     char** h_aliases;	//除官方域名外的其他域名
>     int h_addrtype;		//地址类型：AF_INET/AF_INET6
>     int h_length;		//IP地址长度：IPv4——4，IPv6——16
>     char** h_addr_list;	//IP地址列表
> }
> ```
>
> ![image-20211014090151603](https://i.loli.net/2021/10/14/Nz7C2L64GtOFS3V.png)
>
> **未存储的地方存储的是NULL，h_aliases和h_addr_list存储的是指针数组的地址。**
>
> ***注意：h_addr_list指向的数组实际保存的是in_addr类型变量的地址，而不是char类型地址（主要是为了兼容IPv6）。所以在读取h_addr_list时要强转IP addr #的地址，改变读取内存的长度，以in_addr变量类型读取addr #。***
>
> ***in_addr即sockaddr_in结构体中sin_addr的类型***

```c++
#include<iostream>
#include<cstring>
#include<sys/socket.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<netdb.h>
using namespace std;

int main(int argc, char** argv){
        struct hostent* host;
        host = gethostbyname(argv[1]);

        if(host == NULL){
                cout<<"gethostbyname error.."<<endl;
        }

        cout<<"official name:"<<host->h_name<<endl;
        int i=0;
        while(host->h_aliases[i]!=NULL){
                cout<<"name list:"<<host->h_aliases[i]<<endl;
                i++;
        }


        cout<<"addr type:"<<((host->h_addrtype == AF_INET)?"AF_INET":"AF_INET6")<<endl;

        cout<<"addr length:"<<host->h_length<<endl;

        int j=0;
        while(host->h_addr_list[j]!=NULL){
                cout<<"IP:"<<inet_ntoa(*(in_addr*)&host->h_addr_list[j])<<endl;
                char str[1024];
                inet_ntop(AF_INET, &host->h_addr_list[j], str, sizeof(str));
                cout<<"IP_:"<<str<<endl;
                j++;

        }
        return 0;
}
```



### （2）gethostbyaddr——由IP地址获取域信息

与gethostbyname相比，属于反向解析。

与gethostbyname不同，gethostbyname会向/etc/hosts文件中查看信息，然后没有对应的话，就会返回上一级的DNS进行解析。而反向解析为什么不会自动解析。

因此hosts文件中没有待解析的IP的话，就会解析失败返回NULL。同时在h_errno中存储错误原因为HOST_NOT_FOUND。

https://www.cnblogs.com/wunaozai/p/3753731.html



```c++
#include<netdb.h>
struct hostent* gethostbyaddr(const char* addr, socklen_t len, int family);
```

> **addr**——in_addr结构体指针。（为了兼容IPv6，定义为char*）
>
> **len**——地址长度
>
> **family**——地址族

```c++
#include<iostream>
#include<cstring>
#include<sys/socket.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<netdb.h>
using namespace std;

int main(int argc, char** argv){
        struct hostent* host;

        sockaddr_in addr_host;
        memset(&addr_host, 0, sizeof(addr_host));
        addr_host.sin_addr.s_addr = inet_addr(argv[1]);

        host = gethostbyaddr((char*)&addr_host.sin_addr, 4, AF_INET);
        if(host == NULL){
                cout<<"gethostbyaddr error.."<<endl;
        }

        cout<<"official name:"<<host->h_name<<endl;
        int i=0;
        while(host->h_aliases[i]!=NULL){
                cout<<"name list:"<<host->h_aliases[i]<<endl;
                i++;
        }


        cout<<"addr type:"<<((host->h_addrtype == AF_INET)?"AF_INET":"AF_INET6")<<endl;

        cout<<"addr length:"<<host->h_length<<endl;

        int j=0;
        while(host->h_addr_list[j]!=NULL){
                cout<<"IP:"<<inet_ntoa(*(in_addr*)&host->h_addr_list[j])<<endl;
                char str[1024];
                inet_ntop(AF_INET, &host->h_addr_list[j], str, sizeof(str));
                cout<<"IP_:"<<str<<endl;
                j++;

        }

        return 0;
}
```



---



## 12. socket可选项

### （1）getsockopt ——获取可选项的值

```c++
#include<sys/socket.h>
int getsockopt(int sock, int level, int optName, void* optVal, socklen_t* valLen);
```

> sock——获取/设置可选项的套接字
>
> level——可选项所在层
>
> optName——选项名
>
> optVal——传存储选项值
>
> valLen——传选项值变量的字节数
>
> ```c++
> socklen_t valLen = sizeof(optVal);
> ```
>
> 返回值——成功返回0，失败返回-1

```c++
int sock_type;	//SOCK_STREAM为1，SOCK_DGRAM为2
socklen_t optlen = sizeof(sock_type);
int state = getsockopt(sock, SOL_SOCKET, SO_TYPE, (void*)&sock_type, &optlen);		//注意：get取长度地址
cout << sock_type << endl;
```

SO_TYPE是只读可选项，因为套接字类型只有在创建时才能设定。

### （2）setsockopt——设置可选项的值

```c++
#include<sys/socket.h>
int setsockopt(int sock, int level, int optName, void* optVal, socklen_t valLen);	//注意：set取长度的值
```

### （3）SO_SNDBUF和SO_RCVBUF——IO缓冲区大小可选项

```c++
//获取IO缓冲区大小
#include<iostream>
#include<sys/socket.h>
#include<unistd.h>
using namespace std;

int main(int argc, char** argv){
        int sock = socket(PF_INET, SOCK_STREAM, 0);
        int snd_buf;
        int rcv_buf;
        int len;
        int state;

        len = sizeof(snd_buf);
        state = getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (void*)&snd_buf, (socklen_t*)&len);
        if(state==-1){
                cout<<"getsockopt error.."<<endl;
        }

        len = sizeof(rcv_buf);
        state = getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (void*)&rcv_buf, (socklen_t*)&len);
        if(state==-1){
                cout<<"getsockopt error.."<<endl;
        }
        return 0;

}
```

```c++
//设置IO缓冲区大小
#include<iostream>
#include<sys/socket.h>
#include<arpa/inet.h>
#include<unistd.h>
using namespace std;

int main(int argc, char** argv){
        int sock = socket(PF_INET, SOCK_STREAM, 0);
        int snd_buf;
        int rcv_buf;
        int len;
        int state;

        snd_buf = atoi(argv[1]);
        rcv_buf = atoi(argv[1]);

        len = sizeof(snd_buf);
        state = setsockopt(sock, SOL_SOCKET, SO_SNDBUF, (void*)&snd_buf, (socklen_t)len);
        if(state==-1){
                cout<<"getsockopt error.."<<endl;
        }

        len = sizeof(rcv_buf);
        state = setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (void*)&rcv_buf, (socklen_t)len);
        if(state==-1){
                cout<<"getsockopt error.."<<endl;
        }

        state = getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (void*)&snd_buf, (socklen_t*)&len);
        if(state==-1){
                cout<<"getsockopt error.."<<endl;
        }
        cout<<"output buff size:"<<snd_buf<<endl;
        state = getsockopt(sock, SOL_SOCKET, SO_RCVBUF, (void*)&rcv_buf, (socklen_t*)&len);
        if(state==-1){
                cout<<"getsockopt error.."<<endl;
        }
        cout<<"input buff size:"<<rcv_buf<<endl;

        return 0;
}

```

### （4）SO_REUSEADDR——将处于Time-wait状态下的套接字端口号重新分配给新的套接字

TCP断开连接发起者不仅仅限于client，server也可以发出断开连接请求FIN。不论是client还是server，作为断开连接发起者，都会进入Time-wait状态。

为了防止被断开端未收到ACK而重发FIN，主动断开端设置Time-wait，Time-wait期间若收到重发的FIN，则会再次发送ACK，确保被断开端可以关闭连接。

处于Time-wait期间，收到对端重发的FIN，Time-wait计时器会重启。这样，若ACK频繁丢失，被断开端则会频繁发送FIN导致Time-wait一直重置。

处于Time-wait的连接所占用的端口，若再次bind会出现bind error。所以用Ctrl-c（**Ctrl-c是终止程序，Ctrl-z是中断程序挂起进程，fg会继续在前台运行，bg会在后台继续运行**）终止服务端程序时，服务端作为断开连接发起者会进入Time-wait，若立即用之前的端口号启动服务端程序会错误，一般等待2~3分钟后端口可重新使用。

为什么在客户端程序Ctrl-c后，立即运行客户端程序不会出现错误呢？因为客户端中只有服务端地址addr_serv需要赋值用于sock_clnt的connect，sock_clnt自身的端口是connect时动态分配的，不需要在程序中设置。

#### 可以将SO_REUSEADDR设置为1，处于Time-wait状态下的套接字的端口号就可以立即重新被使用，在server端Ctrl-c后就可以立即重新使用绑定的端口。SO_REUSEADDR的默认值是0。

```c++
//server.cpp
int sock_serv  = socket(PF_INET, SOCK_STREAM, 0);
int option = 1;
socklen_t optlen = sizeof(option);
setsock(sock_serv, SOL_SOCKET, SO_REUSEADDR, (void*)&option, optlen);
```



### （5）TCP_NODELAY——使用/禁用Nagle算法

TCP默认是使用Nagle算法的，则TCP_NODELAY默认为0。将TCP_NODELAY设为1时，禁用Nagle算法。

![image-20211014171109542](https://i.loli.net/2021/10/14/5SpNWzTFjuoOwgb.png)

使用Nagle算法时，只有收到上次发送数据的ACK时才发送下一个数据，可以明显减少数据包的个数。在未收到上次数据的ACK时，数据将会存储在输出缓冲区。而不用Nagle算法时，输出缓冲区一收到数据就立刻发送。

使用Nagle算法的目的是减少包的数量，减少网络拥塞的出现。

"大文件数据"应禁用Nagle算法。 换言之，如果有必要，就应禁用Nagle算法 。

```c++
//设置
int optval = 1;	//1禁用，0启用。
setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void*)&optval, sizeof(optval));
//查看
int optval;
socklen_t optlen = sizeof(optval);
getsockopt(sock, IPPROTO_TCP, TCP_NODELEY, (void*)&optval, &optlen);
if(optval == 0){
    cout<<"Nagle启用"<<endl;
}else if(optval == 1){
    cout<<"Nagle禁用"<<endl;
}
```



---

## 13. 多进程服务器端

### （1）fork——创建进程

#### 进程

在内存中正在运行的程序

#### CPU核心数

CPU有几个运算器就有几个核，就可以在物理意义上同时运行几个进程，而无需分时

#### PID

进程被创建时，OS自动分配的ID，ID=1的进程在OS启动时分配给首个进程（协助OS的进程）。用户进程的PID不会分配1

#### ps au

查看所有进程PID和状态

![image-20211015134844063](https://i.loli.net/2021/10/15/EedCXywN5lOPmVG.png)

**STAT——Linux上进程的状态**

![image-20211015141015070](https://i.loli.net/2021/10/15/8aBpliUhPROrev2.png)

#### fork

调用fork的进程将创建子进程，OS将父进程在内存中的所有数据（代码、数据）拷贝。在父进程中的fork返回后，内存中拷贝的那份数据也将同父进程一样，继续执行fork后的代码。

**内存中两份数据，执行互不干扰，同名的变量的值也是各自的。两个进程只是共用同一份代码。**

父进程中的fork语句返回子进程PID，子进程的fork语句返回0。在代码中通过对PID的判断，**来决定后续的代码块由父进程执行或是子进程执行。**

```c++
pid_t fork();
```

> 返回值——成功返回进程PID，失败返回-1。

```c++
#include<iostream>
#include<unistd.h>
using namespace std;

int gval = 10;
int main(int argc, char** argv){
        int val = 20;
        pid_t pid;
        pid = fork();
        if(pid == 0){
                gval--;
                val--;
                cout<<"child process_"<<pid<<",gval="<<gval<<",val="<<val<<endl;
        }else{
                gval++;
                val++;
                cout<<"parent process_"<<pid<<",gval="<<gval<<",val="<<val<<endl;
        }
        return 0;
}
```

### （2）僵尸进程——defunct进程

#### 产生原因

进程执行完main后，未被销毁仍占用系统资源。

进程执行完main后，会将return**结束状态值**或exit的参数值传递给OS。OS不会销毁这些执行完程序的进程，直到将子进程返回的这些**结束状态值**传递给父进程，才会销毁子进程。处在这种状态下的子进程就是僵尸进程。

但是，OS不会主动将子进程返回的**结束状态值**传递给父进程，只有父进程通过调用函数主动要求获得子进程的**结束状态值**，OS才会传递随后销毁僵尸进程。在此之前，OS将一直保存**结束状态值**。

若父进程不主动调用函数销毁僵尸进程，待父进程结束被OS销毁后，对应的子进程也会随之被销毁。

总结：父进程fork出子进程，子进程执行完后，若父进程未结束，需要手动销毁子进程（让父进程主动请求子进程返回值）。

![image-20211015140948739](https://i.loli.net/2021/10/15/9DCjbIiPJYRO72k.png)

![image-20211015141219323](https://i.loli.net/2021/10/15/tRkSaNEHsnlwu7W.png)

### （3）僵尸进程销毁

#### wait

```c++
#include<sys/wait.h>
pid_t wait(int* status);
```

> status——接收OS传递过来的**结束状态值**
>
> 返回值——成功时返回被销毁子进程的PID，失败返回-1

***wait函数可等待父进程创建的任意僵尸子进程进行销毁，若执行wait时没有子进程，wait就会阻塞，直到有子进程执行完毕成为僵尸进程。***

若成功销毁子进程，则**结束状态值**则会被传递到status中，通过宏进行分离：

> **WIFEXITED(status)**——若子进程正常被销毁，则返回true
>
> **WEXITSTATUS(status)**——返回子进程返回的**结束状态值**

```C++
#include<iostream>
#include<unistd.h>
#include<sys/wait.h>
#include<cstring>
using namespace std;

int main(int argc, char** argv){
        pid_t pid = fork();
        int status;

        if(pid == 0){
                return 1;
        }
    	else{
                cout<<"child process:"<<pid<<endl;
                pid = fork();
                if(pid == 0){
                        return 2;
                }
            	else{
                        cout<<"child process:"<<pid<<endl;
                        wait(&status);
                        if(WIFEXITED(status)){
                                cout<<"child process"<<WEXITSTATUS(status)<<" is killed..."<<endl;
                        }
                        wait(&status);
                        if(WIFEXITED(status)){
                                cout<<"child process"<<WEXITSTATUS(status)<<" is killed..."<<endl;
                        }
                        sleep(60);	//主进程休眠，ps au查看提供时间
                        return 0;
                }
        }
}
```

![image-20211015150203973](https://i.loli.net/2021/10/15/zJCHGUlAg9FaWfm.png)

#### waitpid——不用wait，用waitpid

***同wait不同，不会阻塞！！当前若没有执行完毕的子进程，就会返回0***

***统一用waitpid，需要等待子进程执行完销毁的话，将pid==-1***

```c++
#include<sys/wait.h>
pid_t waitpid(pid_t pid, int* status, int options);
```

> pid——指定要销毁的僵尸子进程。**取-1时，同wait，表示可等待任意子进程执行完毕进行销毁**
>
> options——传递常量WNOHANG，表明没有待销毁的僵尸子进程时不阻塞HANG，返回0

```c++
//更换c++代码风格为K&R
//函数花括号另起一行，其他花括号如if的左花括号紧跟if
#include<iostream>
#include<unistd.h>
#include<sys/wait.h>
#include<cstring>
using namespace std;

int main(int argc, char** argv)
{
        pid_t pid;
        pid = fork();
        int status;
        if(pid == 0){
                sleep(30);
                return 1;
        }else{
                while(waitpid( -1, &status, WNOHANG) == 0 ){
                        sleep(5);
                        cout<<"sleep 5s"<<endl;
                }
                if(WIFEXITED(status) == true){
                        cout<<"child process return value="<<WEXITSTATUS(status)<<endl;
                }
                return 0;
        }
}
```

![image-20211015162952443](https://i.loli.net/2021/10/15/gnhTkwrUQ8CFiWK.png)

### （4）信号处理

#### 函数指针回忆

* C风格：定义函数指针类型，再给指针赋值

  ```c++
  int func(int a, int b){
      return a + b;
  }
  typedef int (*FP)(int, int);
  FP fp = func;
  ```

* C风格：直接定义函数指针

  ```c++
  int (*fp)(int a, int b){
      return a + b;
  }
  ```

* C++风格

  ```c++
  #include<functional>
  int func(int a, int b){
      return a + b;
  }
  typedef functionral<int <int, int>> FP;
  FP fp = func;
  ```

  ```c++
  #include<functional>
  int func(int a, int b){
      return a + b;
  }
  functional<int <int, int>> fp = func;
  ```

* 函数指针作为函数参数

  ```c++
  int (*fp)(int a, int b){
      return a + b;
  }
  void func2(int n, int m, int (*fp)(int a, int b)){
      ...
      fp(n, m);
  }
  ```

  

#### 信号——当特定事件发生时，OS向调用程序发送的消息

> * **SIGALRM**——alarm函数计时结束
> * **SIGINT**——输入Ctrl-C
> * **SIGCHLD**——子进程终止

#### 信号注册——给信号关联信号处理器（Handler）

**当对应信号发生时，OS提醒注册信号的进程调用Handler。并且，若注册信号的进程在休眠，OS将唤醒该进程终止其休眠以调用Handler。**

```C++
#include<signal.h>
void (*signal(int sig, void (*func)(int)))(int);
```

> 解释一下该函数的申明怎么读，后面附带的两个(int)的意思是：该符号前的函数指针所对应的函数是带一个int类型的参数的。比如最外面的，是说signal返回的函数指针所对应的函数是带int的参数的；里面的，作为参数的函数名是带一个int参数的。
>
> **中间部分：**
>
> ```
> signal(int sig, void (*func)(int))
> ```
>
> signal函数有2个参数，第一个是int，**第二个是无返回值，带一个int参数的函数指针，该函数是信号处理函数Handler**
>
> **外围：**
>
> ```
> void   (*signal(xxx))   (int)
> ```
>
> **signal函数返回的是一个函数指针，无返回值，有一个int参数**
>
> **简化：**
>
> ```
> typedef void Sigfunc(int)
> ```
>
> Sigfunc就代表的就是一个 **返回值是一个无返回值，有一个int参数的函数**。
>
> 最后就成了这样:
>
> ```
> Sigfunc *signal(int, Sigfunc*)
> ```

#### alarm函数

**计时结束时，发生SIGALRM信号**

```C++
#include<unistd.h>
unsigned int alarm(unsigned int seconds);
```

> seconds——设定倒计时的时间。赋值0时，会将之前对alarm的设定计时取消
>
> 返回值——返回当前距计时结束发生SIGALRM剩余的秒数

#### sigaction函数

功能完全可替代signal函数，signal是保持对旧程序的兼容，现在实际中已用sigaction函数

```c++
#include<signal.h>
int sigaction(int signo, const struct sigaction* act, const struct sigaction* oldact);
```

> signo——信号
>
> act——存储Handler信息的结构体的地址
>
> oldact——获取存储着上一个Handler函数的结构体的地址，一般置0

```c++
struct sigaction{
    void* sa_handler (int);
    sigset_t sa_mask;
    int sa_flags;
}
```

> sa_handler——指向Handler函数的函数指针
>
> sa_mask——sigemptyset将各位初始化为0
>
> sa_flags——一般置0

```c++
#include<iostream>
#include<unistd.h>
#include<signal.h>

void timeout(int sig){
    if(sig == SIGALRM){
        std::cout<<"timeout.."<<std::endl;
    }
    alarm(2);
}

int main(int argc, char** argv){
    struct sigaction act;
    act.sa_handler=timeout;
    sigemptyset(&act.sa_mask);
    act.sa_flags=0;
    
    sigaction(SIGALRM, &act, 0);
    alarm(2);
    
    for(int i=0;i<3;i++){
        std::cout<<"wait.."<<endl;
        sleep(100);		//进程休眠100s，但alarm计时到2s时，OS会唤醒进程
    }
    return 0;
}
```

#### 利用信号处理sigaction销毁僵尸进程

```c++
#include<iostream> 
#include<signal.h> 
#include<wait.h> 
#include<unistd.h>
using namespace std;

void child_proc(int sig)
{
        int status;
        if(sig == SIGCHLD){
                waitpid(-1, &status, WNOHANG);
        }
        if(WIFEXITED(status)){
                cout<<"child zombie proc has been destroyed.."<<endl;
                cout<<"child proc return val = "<<WEXITSTATUS(status)<<endl;

        }
}
int main(int argc, char** argv){
        struct sigaction act;
        act.sa_handler = child_proc;
        act.sa_flags = 0;

        sigaction(SIGCHLD, &act, 0);

        pid_t pid = fork();

        if(pid == 0){
                cout<<"i'm child proc.."<<endl;
                sleep(5);
                return 1;
        }else{
                cout<<"child proc id = "<<pid<<endl;
                pid = fork();

                if(pid == 0){
                        cout<<"i'm child proc.."<<endl;
                        sleep(5);
                        return 2;
                }else{
                        cout<<"child proc id = "<<pid<<endl;
                        for(int i=0;i<3;i++){
                                cout<<"wait.."<<endl;
                                sleep(5);

                        }

                }

        }
}
```

![image-20211021111828788](https://i.loli.net/2021/10/21/VKR2FUyGLZC31AJ.png)

第二个wait后主进程进入第二个sleep(5)，但是SIGCHLD信号发生，导致OS将主进程唤醒处理child_proc，打印child zombie proc has been destroyed..和

child proc return val =2。由于主进程已被唤醒，就立即打印了第三个wait进出入了第三个sleep(5)，然后执行child_proc。

### （3）基于多进程的并发服务器端

#### 模型

![image-20211020133854878](https://i.loli.net/2021/10/20/zEZ8womG6eUQ2ds.png)

父进程只负责处理客户端的连接请求，子进程对客户端的连接进行处理。

待连接上后，accept每提取一个连接，就fork一个子进程，处理相应请求。

#### 代码

```c++
//multiProcess_server.cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define BUF_SIZE 30
void error_handling(char *message);
void read_childproc(int sig);

int main(int argc, char *argv[])
{
	int sock_listen, sock_clnt;
	struct sockaddr_in serv_adr, clnt_adr;
	
	pid_t pid;
	struct sigaction act;
	socklen_t adr_sz;
	int str_len, state;
	char buf[BUF_SIZE];
	if(argc!=2) {
		printf("Usage : %s <port>\n", argv[0]);
		exit(1);
	}

	act.sa_handler=read_childproc;
	sigemptyset(&act.sa_mask);
	act.sa_flags=0;
	state=sigaction(SIGCHLD, &act, 0);
	sock_listen=socket(PF_INET, SOCK_STREAM, 0);
	memset(&serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family=AF_INET;
	serv_adr.sin_addr.s_addr=htonl(INADDR_ANY);
	serv_adr.sin_port=htons(atoi(argv[1]));
	
	if(bind(sock_listen, (struct sockaddr*) &serv_adr, sizeof(serv_adr))==-1)
		error_handling("bind() error");
	if(listen(sock_listen, 5)==-1)
		error_handling("listen() error");
	
	while(1)
	{
		adr_sz=sizeof(clnt_adr);
		sock_clnt=accept(sock_listen, (struct sockaddr*)&clnt_adr, &adr_sz);
		if(sock_clnt==-1)
			continue;
		else
			puts("new client connected...");
		pid=fork();
		if(pid==-1)
		{
			close(sock_clnt);		//pid==-1表明创建子进程失败。关闭负责通信的sock_clnt
			continue;
		}
		if(pid==0)
		{
			close(sock_listen);		//pid==0，表明是子进程执行的代码：子进程关闭负责监听的套接字
			while((str_len=read(clnt_sock, buf, BUF_SIZE))!=0)
				write(clnt_sock, buf, str_len);
			
			close(sock_clnt);
			puts("client disconnected...");
			return 0;		//子进程被销毁
		}
		else
			close(sock_clnt);		//pid!=0表明是父进程执行的代码：父进程不负责通信，所以关闭负责通信的套接字sock_clnt
	}
	close(sock_listen);
	return 0;
}

void read_childproc(int sig)
{
	pid_t pid;
	int status;
	pid=waitpid(-1, &status, WNOHANG);
	printf("removed proc id: %d \n", pid);
}
void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```

#### 子进程拷贝父进程收到的sock_clnt

当父进程fork一个子进程时，子进程会将父进程中的sock_clnt拷贝一份。但是，这并不意味着将套接字也拷贝了一份，套接字还是一个，子进程拷贝的是套接字的文件描述符。

若有多个文件描述符同时“指向”一个套接字时，必须将***所有***的文件描述符都销毁，才能销毁该套接字。（类似于智能指针）

#### 父进程、子进程首先都要关闭自己不需要的socket

![image-20211021092221447](https://i.loli.net/2021/10/21/ZqgilWLv47Axzr8.png)

父进程只需要处理连接，因为所有指向套接字的文字描述符都必须都销毁才能销毁套接字。所以在fork以后立即将不需要的文件描述符销毁。

父进程销毁负责通信的套接字sock_clnt

子进程销毁负责监听的套接字sock_listen

### （4）基于多进程分割IO的TCP客户端

![image-20211021093424029](https://i.loli.net/2021/10/21/MpHonFE6P3qv7TB.png)

#### 模型

客户端的IO分割（Routine）即将接收、发送分别放在两个进程中，父进程负责接收，子进程负责发送。

不分割时，客户端代码是循环send再recv，因此只有recv到数据后才能执行send。若分割，则recv和send分开，可以同时进行，大大提高数据发送的速率。

#### 代码

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define BUF_SIZE 30
void error_handling(char *message);
void read_routine(int sock, char *buf);
void write_routine(int sock, char *buf);

int main(int argc, char *argv[])
{
	int sock;
	pid_t pid;
	char buf[BUF_SIZE];
	struct sockaddr_in serv_adr;
	if(argc!=3) {
		printf("Usage : %s <IP> <port>\n", argv[0]);
		exit(1);
	}
	
	sock=socket(PF_INET, SOCK_STREAM, 0);  
	memset(&serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family=AF_INET;
	serv_adr.sin_addr.s_addr=inet_addr(argv[1]);
	serv_adr.sin_port=htons(atoi(argv[2]));
	
	if(connect(sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr))==-1)
		error_handling("connect() error!");

	pid=fork();
	if(pid==0)
		write_routine(sock, buf);
	else 
		read_routine(sock, buf);

	close(sock);
	return 0;
}

void read_routine(int sock, char *buf)
{
	while(1)
	{
		int str_len=read(sock, buf, BUF_SIZE);
		if(str_len==0)
			return;

		buf[str_len]=0;
		printf("Message from server: %s", buf);		//buf要输出，所有给末尾加上'\0'
	}
}
void write_routine(int sock, char *buf)
{
	while(1)
	{
		fgets(buf, BUF_SIZE, stdin);
		if(!strcmp(buf,"q\n") || !strcmp(buf,"Q\n"))
		{	
			shutdown(sock, SHUT_WR);		//半关闭，为了可以在结束输入以后仍然可以接收服务端发送的数据
			return;
		}
		write(sock, buf, strlen(buf));
	}
}
void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```





