# 网络基础

## 1. 网络层——建立主机到主机的通信

IP数据报以**比特流bit**形式在物理连接上传输

### （1）IP地址格式

* IP=net-id+host-id，给出了**网络部分**，给出计算机所处的子网；**主机部分**计算机的主机地址。

  IPv4——32bit

  IPv6——128bit

* 划分子网

  子网掩码——那我怎么知道网络部分和主机部分分别占几位呢？解决方案是引入**子网掩码**，他也是32位二进制数，并规定网络部分全为1，主机部分全为0。子网掩码实质是确定IP地址中网络号net-id和主机号host-id的位数

  有了子网掩码，就知道了哪些是网络部分，进而**只需要把两个IP地址网络部分的网络部分对比，就知道是否在同一个子网中**

  划分子网的分片IP数据报`路由转发机制`——从分片IP数据报的首部获取目的地址，与当前路由所在网段的子网掩码AND，若与当前网段号相同，则转发到当前子网中的主机；若不同，则从当前路由的路由表依次将目的地址与子网掩码AND，若得到相同的网段则转发到相应的网关（路由）；否则，转发到默认路由或转发分组出错。

* 网段：主机号少2个，host-id全1表示广播地址（代表所有主机），全0表示网络号

### （2）IP首部校验和

[IP首部校验和计算方法](https://blog.csdn.net/clangke/article/details/6216610?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control)

[校验和计算时最高位产生进位时不能舍去，需要拆分后，将高位加到低位上](https://blog.csdn.net/yiluyangguang1234/article/details/78026020)

[IP首部校验算法](https://www.cnblogs.com/fhefh/archive/2011/10/18/2216885.html)

* 计算：

> 将某个分片IP数据报的校验字段清零
>
> 对首部的20个字节，每2字节进行反码求和（求和后取反），若相加后最高位有进位，那么不能舍弃，一定要加到低位，才能是结果正确。如0x0319BB 拆分成0X03+0X19BB

* 校验：

> 将接收到的校验和同每2字节进行反码求和，若结果为FF FF则表明IP数据包无错误，否则将该IP数据包片丢弃

```C#
对如下十六进制数据求反码校验和：

0x45c0,0x0044,0x0009,0x0000,0x0159,0x0000（归零的校验和）,0x5900,0x0009,0xe000,0x0005

对以上数据直接相加得结果：0x180bd 

按照2中规则，对此数据的处理应该是将16位数最高位的进位0x01与0x80bd相加，即得到中间结果：0x80be

按照3中规则对其取反即得校验和：0x7f41
```

### （3）IP数据报格式IP datagram

* 报头最少20字节。**总长46B~1500B**。

* 标识16bit

  由同一数据报分片得到的`分片数据报`的标识

* 标志3bit

  ```C#
  未使用1bit、DF不分片1bit、MF片未完1bit
  ```

* 片偏移13bit

  标明`分片数据区`在原数据报的`数据区`的位置。字节/8。

* 分片重组机制

  分片——将原数据报分片后加入新的报头（报头是原数据报报头的复制），通过网络的不同路径传输到目标主机。提高了效率，当出现错误时的代价较小。

  重组——通过`标识`判断是否属于同一数据报；通过`标志`的`MF`判断是否是最后一片；根据`偏移量`确定在数据报中的位置。

### （4）路由转发分片IP数据报

**通过查找路由表，判断是否在当前局域网以及不在局域网时的转发路由是什么。关键是，路由可以同时处在两个不同的局域网中。**

* 若目的主机和当前路由在同一个局域网中（网络号相同），则直接通过本路由的某个接口交付。
* 若目的主机和当前路由不在同一个局域网，但是有和目的主机在同一局域网的路由器在当前局域网。则当前路由器通过路由表查找到转发路由，将数据报转发到转发路由。由转发路由再在目标网络中转发数据报。

### （5）ARP地址解析协议

* IP	<-------->	MAC

* ARP缓存
* **在缓存中未找到对应MAC时：**

### （6）ICMP协议报文

* 两类：ICMP错误报告报文、ICMP查询报文

* ICMP错误报告报文格式：从错误分片IP数据报取出报头，首位各加8字节作为数据区，再加上ICMP错误报告报头。

* ICMP查询报文：

  PING指令调用网络层命令，发送请求与回复报文

  ARP地址解析时，从ARP缓存中没有查找到相应MAC时，在集线器上广播自身IP和MAC以及查找的IP时，对应IP回复时的报文

## 2. 传输层——建立端口到端口的通信

### （1）UDP

* 无连接（无逻辑连接），所以可以一对多，多对多，可承担广播、多播
* 不可靠（尽最大可能交付，接收端不返回确认报文）、
* 半双工（发送端和接收端交替发送）
* **面向数据报，应用层数据加上8B报头就直接送往发送缓存**
* 简单快速、耗费资源少。
* **适用于对丢包不敏感的领域：视频、直播、物联网等**

* UDP报文段格式

  伪首部12字节，首部8字节（2字节源地址、2字节目的地址、2字节包长度、2字节校验和checksum）

* 校验和

  同IP校验和只计算分片IP数据报报头不同，计算UDP报文段整个部分（伪首部、首部、数据区）

* 应用层传下来的数据到`发送缓存`，传输层从发送缓存取出数据，以UDP协议传输

* socket=IP：port

  IP只指定主机，port指定进程。socket实质是进程间通信

  UDPsocket只有目的地址+目的端口

### （2）TCP

* TCP socket需要源地址+源端口、目的地址+目的端口

* 有连接，一对一

* 全双工

* 面向字节，以字节为单位传输

* 可靠传输

  等待确认——序号seq（**随机产生一个值seq**（[这样可避免黑客很容易猜到序列号而发起攻击](https://blog.csdn.net/qq_40910541/article/details/88760627)）、确认号ack（确认应答超时、确认应答丢失、）、连续ARQ协议（连续发送、累积确认）

  > ARQ协议：停止等待*ARQ*协议、回退ARQ和连续*ARQ*协议
  >
  > https://blog.csdn.net/jmq_0000/article/details/7299910

  超时重传——超时时间确定公式

  流量控制——滑动窗口rwnd，**发送端**以3个指针维护四个区域，发送缓冲区。

  > 在确认应答策略中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，这样做有一个比较大的缺点，就是性能比较差，尤其是数据往返的时间长的时候。
  >
  > （1）接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK来通知发送端
  >
  > （2）窗口大小字段越大，说明网络的吞吐率越高
  >
  > （3）窗口大小指的是无需等待确认应答而可以继续发送数据的最大值，即就是说不需要接收端的应答，可以一次连续的发送数据
  >
  > （4）操作系统内核为了维护滑动窗口，需要开辟发送缓冲区，来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉
  >
  > ps：发送缓冲区如果太大，就会有空间开销
  >
  > （5）接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端，发送端收到这个值后，就会减慢自己的发送速度
  >
  > （6）如果接收端发现自己的缓冲区满了，就会将窗口的大小设置为0，此时发送端将不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端
  >
  > （7）在TCP的首部中，有一个16为窗口字段，此字段就是用来存放窗口大小信息的
  >
  > 原文链接：https://blog.csdn.net/borderhz/article/details/117284318
  >
  > 

  拥塞控制——拥塞窗口cwnd，发送端取rwnd和cwnd较小者作为发送窗口大小。**快速重传、快速恢复**算法设置cwnd长度（字节）

* 连接建立与断开——三次握手、四次挥手

  https://zhuanlan.zhihu.com/p/78244069

  > #### **为什么需要三次握手？**
  >
  > TCP的连接因为是全双工的，也就是Client和Server两端，发送消息两个方向的连接都要建立成功。如果要保证双向连接都成功的话，三次通信是最少的次数了。大于三次的话，后面的次数通信就没有必要了，是在浪费资源。
  >
  > 二次的话，会怎么样，可不可以呢？答案是不可以，我们来看下，下面的场景。
  >
  > 在谈论这个之前，我们先要知道TCP是基于IP协议的，而IP协议是有路由的，IP协议不能够保证先发送的数据先到达，这当中依赖于IP协议底层的网络质量，以及Client与Server之间的路由跳数。
  >
  > Client在发送完Syn消息1，这里称作Syn1之后，假设因为网络原因，Syn1并没有到达Server端，这个时候Client端已经超时，Client之后重新发起SYN消息，这里称作Syn2。结果由于网络原因Syn2先到答Server，Server于是与Client基于Syn2建立了连接，结果没过多久Syn1又到达了Server,Server于是关掉了Syn2建立的那条连接，又重新建立了一条连接。对于Client来说新建立的这条连接是早就过时的，所以Client不会在这条连接上发送任何数据，这就导致了Server端长时间收不到数据，Client新的连接被断掉了。
  >
  > #### **三次握手失败了会怎么样？**
  >
  > 这里要看是在那个阶段失败的，Client在发送SYN之后没有收到ACK消息，Client会进行重传，第一次重传时间5.5-6s之间，第二次重传会是24s，不成功还会继续尝试，伯克利系统在超过75s之后，如果还是不成功，会放弃尝试连接。（备注：这里面的重传时间设置，与底层的定时器设置有过关系，可以参考TCP/IP详解卷1，这里不做详谈。）
  >
  > 如果Server没有收到最后的一次Ack消息，同样的原理，Server也会进行重传第二步的Syn+Ack消息。
  >
  > 四次挥手：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃
  >
  > [MSL、TTL和RTT简介](https://www.cnblogs.com/zhangkele/p/10323588.html)

* TCP报文段TCP segment 格式

  最少20字节的首部

  SYN标志位——新建连接

  FIN——释放连接

  ACK——确认标志
  
  

## 3. 总结

[总结](https://blog.csdn.net/liuchengzimozigreat/article/details/100169829)

[路由器工作原理](https://blog.csdn.net/hhthwx/article/details/78617877)

[MAC表、ARP表、路由表](https://blog.csdn.net/bzhxuexi/article/details/44237633)

> 路由表——网络层，选择最短路径，判断下一跳网关是哪个
>
> ARP表——数据链路层，由IP得出MAC地址（得到下一跳网关的MAC），将目的MAC写入MAC数据帧。
>
> MAC表——用于交换机，用于交换机确定目的MAC对应的主机要通过那个接口发送，实现单播

[详解一次完整的数据包传输过程 -- 层层递进](https://blog.csdn.net/u011563903/article/details/90116368)

> 传输层封装源端口、目的端口
>
> 网络层封装源IP、目的IP
>
> 数据链路层封装源MAC、目的MAC
>
> 层层封装与解封的过程类似于将信件（数据）放入层层信封，每层信封外写入该层信息。某一层的设备只解封到相应层，不会 拆开上一层对应的“内部”的信封，拆开后从信封封面读取该层所需信息。重新封装也是拿一个新的当前层对应的信封，将手里当前的信封装入，并在信封上写上新的发件人、收件人等信息。

[路由器和交换机的区别](https://blog.csdn.net/baidu_32045201/article/details/78305586)

> 集线器工作在第一层物理层，路由器工作在第三层网络层，交换机工作在第二层数据链路层
>
> 路由器和交换机的主要工作如下：
> **路由器：寻址，转发（依靠 IP 地址）**
> **交换机：过滤，转发（依靠 MAC 地址）**
>
> **每一个路由器与其之下连接的设备，其实构成一个局域网**
> 交换机工作在路由器之下，就是也就是**交换机工作在局域网内**
> 交换机用于**局域网内网的数据转发**
> 路由器用于**连接局域网和外网**
>
> 路由器发送数据——广播
>
> 交换机——单播：一个接口接一个host，若MAC表中有目的MAC对应的交换机接口则直接通过相应接口单播转发到目的host；若MAC表中没有目的MAC对应的接口，则通过所有非接收接口进行广播，目的主机接收后返回响应，交换机会将目的主机和接口的对应关系记录到MAC表中，下次发送时就直接向对应接口发送实现单播



# Socket初步

Socket技术即利用了计算机网络的原理，提供了一系列API（函数），来实现以上协议，使得客户端和服务器主机上的进程之间可以互相通信。

[Socket技术详解](https://www.jianshu.com/p/066d99da7cbd)

