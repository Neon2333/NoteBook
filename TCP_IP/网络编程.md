# Part 01

### 1. Socket技术即利用了计算机网络的原理，封装了五层网络模型，提供了一系列API（函数），来实现以上协议，使得客户端和服务器主机上的进程之间可以互相通信。

[Socket技术详解](https://www.jianshu.com/p/066d99da7cbd)

### 2. 文件IO和ANSI标准IO

https://blog.csdn.net/owen7500/article/details/53263981

文件IO——OS提供的底层IO，没有缓冲

标准IO——封装了缓冲机制，调用OS底层IO的IO

### 3. 基本流程

#### （1）server

> ##### 创建套接字——socket
>
> ```c
> //Linux
> #include<sys/socket.h>
> int socket(int domain, int type, int protocol);	//成功返回文件描述符，失败返回-1
> 
> //Windows
> #include<winsock2.h>
> SOCKET socket(int af, int type, int protocol);	//失败返回INVALID_SOCKET
> ```
>
> ##### 套接字绑定地址——bind
>
> ```c
> //Linux
> #include<sys/socket.h>
> int bind(int sock, struct sockaddr* server_addr, socklen_t addrlen);	//成功返回0，失败返回-1
> 
> //Windows
> #include<winsock2.h>
> int bind(SOCKET s, const struct sockaddr* name, int namelen);	//成功返回0，失败返回SOCKET_ERROR
> ```
>
> ```c
> struct sockaddr_in serv_addr;	//定义server地址为sockaddr_in类型
> memset(&serv_addr,0,sizeof(serv_addr));	//置0
> serv_addr.sin_family=AF_INET;	//IPv4
> serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);	//
> serv_addr.sin_port=htons(atoi(argv[1]));	//命令行第2个参数为server监听的端口
> bind(sock,(struct sockaddr*)&serv_addr, sizeof(serv_addr));
> ```
>
> * **INADDR_ANY**
>
> > NADDR_ANY
> > 转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。
> > 比如一台电脑有3块网卡，分别连接三个网络，那么这台电脑就有3个ip地址了，如果某个应用程序需要监听某个端口，那他要监听哪个网卡地址的端口呢？
> >
> > 如果绑定某个具体的ip地址，你只能监听你所设置的ip地址所在的网卡的端口，其它两块网卡无法监听端口，如果我需要三个网卡都监听，那就需要绑定3个ip，也就等于需要管理3个套接字进行数据交换，这样岂不是很繁琐？
> >
> > 所以出现INADDR_ANY，你只需绑定INADDR_ANY，管理一个套接字就行，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
>
> * **htonl——将主机的32位无符号长整形数转换成网络字节顺序**
>
> ```c
> uint32_t htonl(uint32_t hostlong);
> ```
>
> * **htons——将主机的16位无符号短整形数转换成网络字节顺序**
>
> ```c
> uint16_t htonl(uint16_t hostshort);
> ```
>
> * **atoi——把字符串转成整型数，跳过空字符。字符不能转成int或空字符时，无法转换时返回0。**
>
> ```c
> int atoi(const char *nptr); 
> ```
>
> **网络字节顺序**
>
> > 所谓网络字节顺序（大尾顺序）就是指一个数在内存中存储的时候“高对低，低对高”（即一个数的高位字节存放于低地址单元，低位字节存放在高地址单元中）。但是计算机的内存存储数据时有可能是大尾顺序或者小尾顺序。
> >
> > 先举个例子：
> > int a = 0x403214;
> > int b = htonl(a);
> > 我在VC++6.0调试这段代码，发现
> > &a的值为：0x0012ff44
> > 其中0x0012ff44、0x0012ff45、0x0012ff46、0x0012ff47这四个单元的值依次为：14、32、40、00，即0x403214这个数的高位部分存放在高位地址中，低位部分存放在低位地址中，即小尾顺序。
> > &b的值为：0x0012ff40
> > 其中0x0012ff40、0x0012ff41、0x0012ff42、0x0012ff43这四个单元的值依次为：00、40、32、14，即把原数0x403214的高位部分存放在低位地址中，低位部分存放在高位地址中。
> > 由此可见，如果一个数以小尾顺序存储，经htonl函数调用后这个数的高地位字节会完全颠倒过来成为一个新的数。这个新的数在机器内部其实还是以小尾顺序存储的，但是相对于原来的数而言相当于是变成大尾顺序的了。
> > long型的0x40写完整为:0x 00 00 00 40，共四个字节，调用htonl后四个字节颠倒顺序，为0x 40 00 00 00。
> > 同样，0x40 00 00 00调用htonl后变为0x 00 00 00 40，即0x40
>
> * 转为监听状态——Listen
>
>   ```c
>   //Linux
>   #include<sys/socket.h>
>   int listen(int sock, int backlog);	//成功返回0，失败返回-1
>   
>   //Windows
>   int listen(SOCKET s, int backlog);	//成功返回0，失败返回SOCKET_ERROR
>   ```
>
> * 阻塞接收消息——accept
>
>   ```c
>   //Linux
>   #include<sys/socket.h>
>   int accept(int sock, struct sockaddr* client_addr, socklen_t* addrlen);	//成功返回文件描述符，失败返回-1
>     
>   //Windows
>   SOCKET accept(SOCKET s, struct sockaddr* server_addr, int* addrlen);	//成功返回套接字句柄，失败返回INVALID_SOCKET
>   ```
>
>   ```c
>   struct sockaddr_in serv_addr;
>   int clnt_addr_size = sizeof(clnt_addr);
>   accept(sock,(struct sockaddr_in*)&clnt_addr, &clnt_addr_size);
>   ```

#### （2）client

> * 创建套接字
>
> * 连接server——connect
>
>   ```c
>   //Linux
>   int connect(int sock, struct sockaddr* server_addr,socklen_t addrlen);	//成功返回0，失败返回-1
>   
>   //Windows
>   int connect(SOCKET s, const struct sockaddr* name, int namelen);	//成功返回0,，失败返回SOCKET_ERROR
>   ```
>
> * 读写数据——IO

### 4. 创建套接字

#### （1）socket函数

```c
#include<sys/socket.h>
int socket(int domain, int type ,int protocol);	//失败时：-1
```

> domain——协议族
>
> > PF_INET——IPv4
> >
> > PF_INET——IPv6
>
> type——数据传输方式（某个协议族中有多种数据传输方式）
>
> > SOCK_STREAM——面向连接、可靠、有序传输、流量控制、多次发送一次读取
> >
> > SOCK_DGRAM——无连接、不可靠、高速传输、一次发送对应一次读取
>
> protocol——指定具体协议（一般置0，若某协议族中同样数据传输方式的协议有多个，则需要指定具体是哪个协议）
>
> > IPPROTO_TCP
> >
> > IPPROTO_UDP

#### （2）Windows和Linux区别

* Linux中文件和套接字都用文件描述符描述。Windows中分别用文件句柄和套接字句柄描述。

* 关闭socket

  ```c
  //Linux
  sock.close();	//同文件关闭
  //Windows
  closesocket(sock)	//socket关闭函数
  ```

* Windows使用ws2_32.lib库。定义套接字前，需要初始化库。程序结束前，需将库归还OS，之后无法调用socket函数

  ```c
  #include<winsock2.h>
  int WSAStartup(WROD versionWinsock, WSADATA* lpWSAData);	//成功时返回0
  ......
  int WSACleanup();	//成功返回0，失败返回SOCKET_ERROR
  ```

  > versionWinsock——winsock的版本号，通过MAKEWORD函数方便生成版本号，如主版本1副版本2，MAKEWORD(1, 2)生成0x0201，高位为副版本号

  ```c
  int main(int argc, int argv[]){
      WSADATA wsaData;
      if(WSAStartup(MAKEWORD(2,2),&wsaData)!=0){
          Error_handling("WSAStartup error");
      }
      return 0;
  }
  ```

* 两平台函数名、参数名都相同，只是返回值类型使用不同，需关注。

  > Linux——返回int值，保存文件描述符。错误返回-1
  >
  > ```c
  > SOCKET soc = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
  > if(soc == -1){
  >     ErrorHandling();
  > }
  > ```
  >
  > Win——返回值结构体SOCKET，保存整数型套接字句柄值（本质也是int，为了扩展性定义为SOCKET）.错误返回INVALID_SOCKET
  >
  > ```c
  > SOCKET soc = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
  > if(soc == INVALID_SOCKET){
  >     ErrorHandling();
  > }
  > ```

#### （3）Linux建立TCP套接字

```c
/**
*tcp_client.c
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(char* message) ;
4. int main(int argc, char* argv[] )
5. {
6. 		int sock;
7.		struct sockaddr_in serv_addr;
8. 		char message[30] ;
9. 		int str_len=0;
10. 	int idx=0, read_len=0;
11.
12. 	if(argc!=3){
13. 		printf("Use: %s<IP> <port>\n", argv[0]);	//若执行程序的命令行参数不是3，则打印格式："tcp_client <IP> <port>"
14. 		exit(l);
15. 	}
16.
17.      sock=socket(PF_ INET, SOCK_STREAM, 9);
18.      if(sock == - 1)
19. 	 error_handling("socket() error")j
29.
21. 	memset(&serv_addr, sizeof(serv_addr));
22.		serv_addr.sin_family=AF_INET;
23.		serv_addr.sin_addr.s_addr=inet_addr(argv[1]]);	//从命令行参数中取出IP地址
24. 	serv_add.sin_port = htons(atoi(argv[2]));	//从命令行参数中取出端口
25.		if(connect(sock,(sockaddr_in*)&serv_addr, sizeof(serv_addr)) == -1){
    		error_handling("connect error");
		}
    	while(read_len=read(sock,&message[idx++],1)){
            if(read_len == -1){
                error_handling("read error");
            }
            str_len += read_len;
        }
    	 printf("Message from server: %s \n",message);
         printf("function call count: %d \n",str_len);
         close(sock);
    	return 0;
	}	
```

