# 动态库制作

**制作动态库时，一定要注意是x86还是x64，调用的程序不论是C++还是C#都也一定要是对应的CPU编译。**

[博客1](https://blog.csdn.net/qq_30139555/article/details/103621955)

[博客2](https://blog.csdn.net/w_x_myself/article/details/82252646)
[博客3](https://blog.csdn.net/u011555996/article/details/80293812)
[博客4](https://www.jb51.net/article/90111.htm)

## 1. 宏定义

https://blog.csdn.net/a55684471/article/details/102366415

```c++
//用宏定义替代__declspec在头文件中导出dll所需要变量
#define __declspec(dllexport) DLLExport
//导出宏定义
#define __declspec(dllimport) DLLImport
```

DLL.h中在需要暴露的接口声明前加上`extern "C" DLLExport`

导出的接口前除了DLLExport还要加上extern "C"，extern "C"让比编译器以C方式编译该函数，避免C++方式在编译代码时考虑重载而将函数名与参数名组合的方式改变函数名，导致调用DLL的程序找不到接口函数。

```c++
extern "C" DLLExport int g_num;
extern "C" DLLExport int add(int, int);
```

### 引申extern用法：

> * test.c文件中的函数，若main.cpp想要调用，则需要在test.h中对函数声明为extern "C"
>
>   ```c++
>   //test.h
>   extern "C" int add(int, int);
>   ```
>
>   ```c
>   //test.c
>   int add(int a, int b){
>       return a + b;
>   }
>   ```
>
>   ```c++
>   //main.cpp
>   #include "test.h"
>   cout<<add(1, 2)<<endl;
>   ```
>
> * 表明这里的是变量声明，定义在其他文件
>
>   ```c++
>   //test.h
>   extern int g_num;
>   ```
>
>   ```c++
>   //test.c
>   int g_num = 0;
>   ```
>
>   ```c++
>   //main.cpp
>   #include "test.h"
>   func(g_num);
>   ```
>
> * 如果是要定义全局变量，那么在头文件中用extern关键字声明，然后在另一个.cpp文件中定义；
>
> * 如果是要声明一个不想被其他文件使用、只能被本文件使用的变量，可以用static关键字在头文件中进行定义；
>
> * 如果所要定义的变量为局部变量，并且其值在编译时就已经可以确定，就可以用const关键词在头文件中进行定义。

## 2. DLL.h头文件

https://blog.csdn.net/Andy710660541/article/details/111196740

### （1）.h防止重复包含宏定义

```c++
#ifndef _DLL_h_
#define _DLL_h_
...
#endif
```

### （2）该DLLExport哪些东西

* **只有main.cpp中要用的函数、变量等才用DLLExport和DLLImport导入导出。调用程序用不到的东西不要导出。如DLL.h中的getVec()。**

* **DLL本质上是函数库，暴露的是函数接口，全局变量、类等数据类型最好不要直接使用DLLExport的方法暴露。因为C#调用时无法访问导出的全局变量、类等，且C#使用CppDLL存在数据类型不一致的问题。**

* **不论是普通函数还是类的成员函数，想要暴露出作为接口被其他程序调用都要用DLLExport和DLLImport。成员函数想要能够被调用，仅仅导出导入类是不行的（不导出类，仅仅导出类的成员函数也可以访问public的成员函数）。但是全局变量的话必须要导出，才能被调用的程序访问到。**

### （3）注意事项

* **定义的全局变量前需要加上extern，不然的话在.cpp文件中定义全局变量会显示重定义**

  [博客1](https://blog.csdn.net/m0_49448331/article/details/109435277)

### （4）code

```c++
//DLL.h
#pragma once
#include<iostream>
#include<vector>
#include<string>
using namespace std;
#define DLLExport  _declspec(dllexport) 
#define DLLImport  _declspec(dllimport) 

DLLExport extern int numVec;	//不能省略DLLExport，否则numVec无法访问。extern表明此处为声明，定义在别的文件处（DLL.cpp处，否则DLL.cpp中的定义会                                 //被看作重定义）

class Person {					//类可以不DLLExport，printName()仍然可以被访问
public:
	Person() {}
	Person(string n) {
		this->name = n;
	}
	string name;
	~Person() {}
public:
	DLLExport void printName();		//Person被DLLExport，若printName不DLLExport，也是不可调用的。PrintName必须要DLLExport
};

extern "C" DLLExport int add(int a, int b);		//extern "C"防止c++的重载机制修改函数名
extern "C" DLLExport int multip(int, int);

extern "C" DLLExport void setNumVec(int val);

extern "C" DLLExport int getNumVec();

//extern "C" DLLExport vector<int> getVec(int);
vector<int> getVec(int);						//getVec不暴露为接口，调用程序中无法访问
extern "C" DLLExport void printVec();
```

```c++
//DLL.cpp
#include"pch.h"
#include"DLL.h"

int numVec = 0;

void Person::printName() {
	cout << "name: " << this->name << endl;
}


int add(int a, int b) {
	return a + b;
}

int multip(int a, int b) {
	return a * b;
}

void setNumVec(int val) {
	numVec = val;
}

int getNumVec() {
	return numVec;
}

vector<int> getVec(int n) {
	vector<int> v;
	v.reserve(n);
	for (int i = 0; i < n; i++) {
		v.push_back(i);
	}
	return v;
}

void printVec() {
	vector<int> tempv = getVec(numVec);
	for (auto it = tempv.begin(); it != tempv.end(); it++) {
		cout << *it << endl;
	}
}
```

### （5）VS工具查看DLL中暴露的接口：

运用的工具：单击Windows图标------>所有程序------>找到相应的Visual Studio文件夹------->选择Visual Studio tool(会打开文件夹)-------->寻找本机工具命令提示。切换到dll文件目录下，运行命令：`dumpbin /EXPORTS 库名`（例：dumpbin /EXPORTS Project2.dll）



---

# 动态库使用

##  C++ VS2019使用

将DLL.h、DLL.lib、DLL.dll拷贝到C++项目根目录下

VS2019在头文件文件夹中`添加现有项`，添加DLL.h

对DLL.h做如下修改：

![image-20211018001220538](https://i.loli.net/2021/10/19/hGZcuvVCJLeP8SF.png)

```c++
//main工程中的DLL.h
//调用程序将DLL.h添加到自己项目的头文件文件夹中，将DLLExport改为DLLImport表明将接口从库文件中导入
#pragma once
#pragma comment(lib, "Dlltest.lib")		//导入库文件

#include<iostream>
#include<vector>
#include<string>
using namespace std;
#define DLLExport  _declspec(dllexport) 
#define DLLImport  _declspec(dllimport) 	//将所有的DLLExport替换为DLLImport

DLLImport extern int numVec;	//导入全局变量

class Person {
public:
	Person() {}
	Person(string n) {
		this->name = n;
	}
	string name;
	~Person() {}
public:
	DLLImport void printName();	//导入成员函数
};

extern "C" DLLImport int add(int a, int b);
extern "C" DLLImport int multip(int, int);

extern "C" DLLImport void setNumVec(int val);

extern "C" DLLImport int getNumVec();

//extern "C" DLLExport vector<int> getVec(int);
vector<int> getVec(int);
extern "C" DLLImport void printVec();
```

```c++
//main.cpp
#include"DLL.h"

int main(int argc, char** argv) {
	cout << "sum=	" << add(2, 3);
	cout << "multi=   " << multip(2, 3);
	numVec = 10;
	printVec();
	
	Person p("wang");
	p.printName();
	return 0;
}
```
